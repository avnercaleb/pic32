/******************************************************************************/
/* Files to Include                                                           */
/******************************************************************************/

#include "user.h"


/******************************************************************************/
/* Variable Declaration                                                       */
/******************************************************************************/
extern volatile UART_STRUCT uart;
extern UART_STRUCT *uartPt;

volatile SYS_STRUCT sys;        /* System struct - configurations, flags, adc values */
SYS_STRUCT *sysPt;

PROF_STRUCT prof;               /* Profiles struct */
PROF_STRUCT *profPt;

ASTRO_STRUCT astro;
ASTRO_STRUCT *astroPt;          /* Astronomical Clock struct */

ALARM_STRUCT alr;
ALARM_STRUCT *alrPt;

volatile PWR_CONSUME_STRUCT pwr;
PWR_CONSUME_STRUCT *pwrPt;

PWR_LF_CAL_STRUCT pwrLFcal;
PWR_LF_CAL_STRUCT *pwrLFcalPt;

extern volatile ADC_STRUCT adc;
extern ADC_STRUCT *adcPt;

extern volatile RF_STRUCT rf;
extern RF_STRUCT *rfPt;

volatile MSGBUFF_STRUCT msgBuff;     /* Struct to create a buffer of the last 3 msgs received */
MSGBUFF_STRUCT *msgBuffPt;

extern RTC_DATA rtc;
extern RTC_DATA *rtcPt;

extern MEMS_STRUCT mems;
extern MEMS_STRUCT *memsPt;

extern PM_STRUCT pm;
extern PM_STRUCT *pmPt;

extern const uint8_t daliDim[];


/* AES 128bit Encryption consts & variables */
uint8_t auxLen;

/* New key generated by a java script */
extern const uint8_t AESKey128[];

/* Variable to receive the session key */
AES_SESSION_KEY_128_BIT session_key;

uint8_t encrypt[MAX_RFMSG_LEN]={0};
uint8_t decrypt[MAX_RFMSG_LEN]={0};
uint8_t auxBuff[MAX_RFMSG_LEN]={0};

uint8_t buffMsg[MAX_RFMSG_LEN];          /* It is necessary to create a continuous buffer before encryption */


/* Strings for some commands */
const uint8_t pwmMsg[]="PWM";
const uint8_t snMsg[]="SRN";
const uint8_t netMsg[]="NET";
const uint8_t resetMsg[]="M1reset2016";
const uint8_t resetWH[]="WHreset2016";
const uint8_t debug[]="M1debug2016";
const uint8_t pirLocalEnable[]="M1pir2016";
const uint8_t confDtFact[]="dtFact";
const uint8_t enc[]="M1enc128";
const uint8_t rf868[]="M1rf868";
const uint8_t rf915[]="M1rf915";
const uint8_t clock[]="CLOCK";
const uint8_t jig[]="JIG"; //Factory Test Command

/* MODBUS commands */
const uint8_t modbusQuery[8] = {0x10,0x04,0x00,0x00,0x00,0x04,0xF8,0xF0};  // Query for SCADA connect
unsigned int crcRx;

const uint8_t versionMsg[]="\r\n\n ONE_SMART_PANEL_V4 17-06-2022\r\n";

/* Aux variables */
uint16_t msgID_len;
uint8_t dtFactInt;      /* Variable used when the debug info is ON */
double fpAux;
uint16_t analog_1, analog_2, analog_3, analog_4;


float v1,v2,v3;
float i1,i2,i3;
float p1,p2,p3;
float kwhSum;
short int fp1,fp2,fp3;  

float volume;

float flowAct = 0.0;
float flowAvg = 0.0;
float flowSum = 0.0;
unsigned int avgCnt = 0;

float quadratic_AN1 = 1.0;
float slope_AN1 = 1.0;
float intercept_AN1 = 0.0;

uint8_t temp;

/******************************************************************************/
/* User Functions                                                             */
/******************************************************************************/

/**
 * Function to config the IO Ports and the Peripherals
 */
__attribute__((mips16)) void Config_IO_Peripherals(void)
{
    uint8_t key[16];

    /* System delay for stable start-up */
    delayMs(10);

    /* Setup analog functionality and port direction */
    PPSUnLock;                  // Unlock Pin Selection

    /* Set UART Ports*/
    PPSInput (3, U1RX, RPB6);
    PPSOutput(1, RPB15, U1TX);

    mPORTBSetPinsDigitalIn(BIT_6);
    mPORTBSetPinsDigitalOut(BIT_15);
   
    /* Set SPI Ports*/
    PPSInput (2, SDI1, RPB5);
    PPSOutput(2, RPB8, SDO1);    

    mPORTBSetPinsDigitalIn(BIT_5);
    mPORTBSetPinsDigitalOut(BIT_8);
    
    PPSLock;                                // Lock Pin Selection

    /* Set of Analog Inputs */
    mPORTASetPinsAnalogIn(BIT_1);                      // RA1 - ANALOG 1
    mPORTBSetPinsAnalogIn(BIT_0 | BIT_1 | BIT_2);      // RB0 - ANALOG 2
                                                       // RB1 - ANALOG 3
                                                       // RB2 - ANALOG 4
    
    /* Set of Digital Inputs */
    mPORTBSetPinsDigitalIn(BIT_7 | BIT_10 | BIT_11 | BIT_12 | BIT_13);  // RB7 - RF Interrupt INT0
                                                                        // RB10 - DIGI 1
                                                                        // RB11 - DIGI 2
                                                                        // RB12 - DIGI 3
                                                                        // RB13 - DIGI 4
   
    /* Set of Digital Outputs */
    mPORTASetPinsDigitalOut(BIT_0 | BIT_2 | BIT_3 | BIT_4);     // RA0 - OUT 1
                                                                // RA2 - OUT 3
                                                                // RA3 - OUT 4
                                                                // RA4 - TX_EN
                                                                
    mPORTBSetPinsDigitalOut(BIT_3 | BIT_4 | BIT_9);             // RB3 - OUT 2
                                                                // RB4 - CS_RF
                                                                // RB9 - CS_RTC
    
    /* Set all CS for SPI communication to OFF*/
    CS_RTC_OFF;         /* Chip select RTC */
    CS_RF_OFF;          /* Chip select RF */
    
    /* Disable RS485 TX */
    RS485_TX_EN;
    
    /* Switch digital out off */
    DIGOUT_1_OFF;
    DIGOUT_2_OFF
    DIGOUT_4_OFF; 
    DIGOUT_3_OFF;
    
    /* System delay for stable start-up */
    delayMs(400);
    
    /* Initialise UART1 */
    UART_Init(UART1, UART_BAUDRATE);

    /* Config Timer 4 to handle with uart messages */
    OpenTimer4(T4_OFF |  T4_SOURCE_INT | T4_PS_1_64, PR_TIMER_EOM);
    ConfigIntTimer4(T4_INT_ON | T4_INT_PRIOR_2 | T4_INT_SUB_PRIOR_1);

#if DEBUG_VERSION_MSG
    /* Show version firmware through UART */
    UART_PrintString(versionMsg);
#endif

    /* Initialise SPI1 */
    SPI_Init(SPI_CHANNEL1, SPI_BAUDRATE);

    /* Initialise Core timer */
    CoreTimer_Init(CORE_TICK_RATE);

    /* Initialise system struct pointer and structure */
    sysPt = &sys;
    memset(sysPt, 0x00, sizeof(SYS_STRUCT));

    /* Set the flag that indicates the beginning of the process */
    sysPt->flagInit = 1;

    /* Initialise profile struct pointer and structure */
    profPt = &prof;
    memset(profPt, 0x00, sizeof(PROF_STRUCT));

    /* Initialise Astronomical struct pointer and structure */
    astroPt = &astro;
    memset(astroPt, 0x00, sizeof(ASTRO_STRUCT));

    /* Initialise alarm struct pointer and structure */
    alrPt = &alr;
    memset(alrPt, 0x00, sizeof(ALARM_STRUCT));

    /* Initialise structure for max current calibration */
    pwrLFcalPt = &pwrLFcal;
    memset(pwrLFcalPt, 0x00, sizeof(PWR_LF_CAL_STRUCT));

    /* Initialise structure for power consumption calculation */
    pwrPt = &pwr;
    memset(pwrPt, 0x00, sizeof(PWR_CONSUME_STRUCT));    
    
    /* Time for the RFM69HCW smart-reset frees the RESET Pin - NOT NEEDED AFTER VERSION ONE_MOC_H (INCLUSIVE) */
    //delayMs(200); 
    
    /* Initialise RF module */
    #ifdef RF_RFM22B
        RF_RFM22B_Init();
    #endif
    #ifdef RF_RFM69HCW
        RF_RFM69HCW_Init();
    #endif 
    #ifdef RF_RFM95W
        RF_RFM95W_Init();
    #endif
    
    /* Initialise RTC/EEPROM */ 
    RTC_MCP7952x_Init();
    
    /* Get saved data from EEPROM */
    RTC_MCP7952x_GetSavedData(sysPt, memsPt, profPt, astroPt, alrPt, pwrLFcalPt, pwrPt, rfPt);  
    
    /* Set configurations of the RF module */
    #ifdef RF_RFM22B
        RF_RFM22B_Config();
    #endif
    #ifdef RF_RFM69HCW
        RF_RFM69HCW_Config();
    #endif
    #ifdef RF_RFM95W
        RF_RFM95W_Config();
    #endif

    /* Initialise the Buffer for the last 3 msgs */
    msgBuffPt = &msgBuff;
    memset(msgBuffPt, 0x00, sizeof(MSGBUFF_STRUCT));
    msgBuff.ordIDact = 0x01;

    /* Config and start ADC - Set the number and which channels */
    ADC_ConfigAutoScan(ADC_N_CH, EN_AN1 | EN_AN2 | EN_AN3 | EN_AN4);

    /* Force Calibration of the RTC at the start-up */
    sys.flagTempComp = 1;

    /* Power-meter structure initialisation */
    pmPt = &pm;
    memset(pmPt, 0x00, sizeof(pm));
    
    /* Initialise AES128 Encryption - Session Key calculation */
    memcpy(key, AESKey128, AES_BLOCK_SIZE);
    AESCreateSessionKey(key, &session_key, AES_KEY_TYPE_128_BIT);
    
    /* System delay for stable start-up */
    //delayMs(150);      
}



/******************************************************************************/
/* UART Functions                                                             */
/******************************************************************************/

/**
 * Function for processing the messages received in the UART1
 * @param 1 - UART_STRUCT pointer
 * @param 2 - SYS_STRUCT pointer
 */
__attribute__((mips16)) void UART_ProcessMsg(UART_STRUCT *uartData, SYS_STRUCT *sysData, PM_STRUCT *pmData,\
                                             PWR_CONSUME_STRUCT *pwrData, RF_STRUCT *rfData, RTC_DATA *rtcData)
{
    uint8_t *buffPt;

    if (memcmp(uartData->rxBuff, pwmMsg, 3) == 0)
    {
        sysData->dtSttMch = atoi(uartData->rxBuff+3);

        /* Save the new dimming to EEPROM */
        buffPt = &sysData->dtSttMch;
        RTC_MCP7952x_WrtEEPROM_Array(DUTY_TMP_ADD, buffPt, 2);

        if (jigFlag == JIG_OFF) 
            UART_PrintString("\nPWM updated\n\n");

        // Set order to do dimming
        sysData->flagDim = 1;

    }
    else if (memcmp(uartData->rxBuff, snMsg, 3) == 0)
    {
        sysData->sn = atoi(uartData->rxBuff+3);

        /* Save to EEPROM the new serial number */
        buffPt = &sysData->sn;
        RTC_MCP7952x_WrtEEPROM_Array(SN_ADD, buffPt, 2);

        if (jigFlag == JIG_OFF) 
            UART_PrintString("\nSN updated\n\n");
    }
    else if (memcmp(uartData->rxBuff, netMsg, 3) == 0)
    {
        sysData->net = atoi(uartData->rxBuff+3);

        /* Save to EEPROM the new network number */
        buffPt = &sysData->net;
        RTC_MCP7952x_WrtEEPROM_Array(NET_ADD, buffPt, 2);

        if (jigFlag == JIG_OFF) 
            UART_PrintString("\nNET updated\n\n");
    }
    else if (memcmp(uartData->rxBuff, resetMsg, sizeof(resetMsg)) == 0)
    {
        RTC_MCP7952X_ClrEEPROM();

        if (jigFlag == JIG_OFF) 
            UART_PrintString("\nEEPROM ERASED!!\n\n");

        /* After a EEPROM clear the system resets*/
        SoftReset();
    }
    else if (memcmp(uartData->rxBuff, resetWH, sizeof(resetWH)) == 0)
    {
        sysData->workHours = 0;
        
        buffPt = &sysData->workHours;
        RTC_MCP7952x_WrtEEPROM_Array(WH_ADD, buffPt, 4);

        if (jigFlag == JIG_OFF) 
            UART_PrintString("\nWH cleared!!\n\n");
    }
    else if (memcmp(uartData->rxBuff, debug, sizeof(debug)) == 0)
    {        
        sysData->debugCtrl = !sysData->debugCtrl;

#if (DEBUG_CHECK_DEBUGCTRL == 0)
        RTC_MCP7952x_WrtEEPROM_Byte(DEBUG_ADD, sysData->debugCtrl);
#endif
    }
    else if (memcmp(uartData->rxBuff, pirLocalEnable, sizeof(pirLocalEnable)) == 0)
    {
        sysData->pirENABLE = !sysData->pirENABLE;
        RTC_MCP7952x_WrtEEPROM_Byte(PIR_ADD, sysData->pirENABLE);

        if (sysData->pirENABLE == PIR_ENABLE)
            if (jigFlag == JIG_OFF) 
                UART_PrintString("\nPIR Detection enabled!!\n\n");
        else
            if (jigFlag == JIG_OFF) 
                UART_PrintString("\nPIR Detection disabled!!\n\n");
    }
    else if (memcmp(uartData->rxBuff, confDtFact, 6) == 0)
    {
        sysData->dutyFact = atof(uartData->rxBuff+6);

        /* Save to EEPROM the Duty Factor */
        buffPt = &sysData->dutyFact;
        RTC_MCP7952x_WrtEEPROM_Array(DUTY_FACT_ADD, buffPt, DOUBLE_SIZE);

        if (jigFlag == JIG_OFF) 
            UART_PrintString("\nDUTY FACT updated\n\n");
    }   
    else if (memcmp(uartData->rxBuff, enc, sizeof(enc)) == 0)
    {
        sysData->encCtrl = !sysData->encCtrl;
        RTC_MCP7952x_WrtEEPROM_Byte(ENC_ADD, sysData->encCtrl);
        
        if (sysData->encCtrl == ENC_ON)
            if (jigFlag == JIG_OFF) 
                UART_PrintString("\nEncryption ON\n\n");
        else
            if (jigFlag == JIG_OFF) 
                UART_PrintString("\nEncryption OFF\n\n");
    }
    else if (memcmp(uartData->rxBuff, rf868, sizeof(rf868)) == 0)
    {
        rfData->freq = RF_868;
        RTC_MCP7952x_WrtEEPROM_Byte(RF_FREQ_ADD, rfData->freq);
        
        /* Reset the RF Module and set the new frequency */
        #ifdef RF_RFM22B
            RF_RFM22B_Reset(rfData);
        #endif
        #ifdef RF_RFM69HCW
            RF_RFM69HCW_Reset(rfData);
        #endif
        
        if (jigFlag == JIG_OFF) 
            UART_PrintString("\nRF frequency set to 868MHz\n\n");
    }    
    else if (memcmp(uartData->rxBuff, rf915, sizeof(rf915)) == 0)
    {
        rfData->freq = RF_918;
        RTC_MCP7952x_WrtEEPROM_Byte(RF_FREQ_ADD, rfData->freq);
        
        /* Reset the RF Module and set the new frequency */
        #ifdef RF_RFM22B
            RF_RFM22B_Reset(rfData);
        #endif
        #ifdef RF_RFM69HCW
            RF_RFM69HCW_Reset(rfData);
        #endif        
        
        if (jigFlag == JIG_OFF) 
            UART_PrintString("\nRF frequency set to 915MHz\n\n");
    }
    else if ((memcmp(uartData->rxBuff, clock, 5) == 0) && (uartData->indRx == 12))
    {
        /* Set order to update the clock - RTC Update */
        memcpy(rtcData, uartData->rxBuff+5, RTC_DATA_SIZE);
        sysData->updateID = RTC_UPDATE;
        
        if (jigFlag == JIG_OFF) 
            UART_PrintString("\nRTC updated\n\n");
    }
    else if (memcmp(uartData->rxBuff, jig, sizeof(jig)) == 0)
    {
        jigFlag = JIG_ON;
        //UART_PrintString("\njig\n");
    }
    else
    {
        /* Power-meter message */
        //pmData->msgAnsRcv = PM_MCP39F501_ProcessMsg(sysData, uartData, pmData, pwrData);        
        
        crcRx = CRC16(uartData->rxBuff, uartData->indRx - 2);  
                       
        if ((uartData->rxBuff[3] == 0) && (uartData->rxBuff[4] == 0) && (uartData->indRx == 13) &&
            (uartData->rxBuff[12] == (uint8_t)(crcRx >> 8)) && (uartData->rxBuff[11] == (uint8_t)(crcRx & 0x00FF)))
        {           
            ConvertLittleToBigEndian(uartData->rxBuff, 9);
            memcpy(&fp3, &uartData->rxBuff[9], 2);
            
            //sprintf(uart.txBuff,"\r\nCO2 = %d", fp3);
            //UART_PrintString(uart.txBuff);
        }
    }

    UART_ClearBuff(uartData->rxBuff, &uartData->indRx);
}


/******************************************************************************/
/* RF Functions                                                               */
/******************************************************************************/

/**
 * Function to process the received RF message
 * @param 1 - RF_STRUCT pointer
 * @param 2 - SYS_STRUCT pointer
 * @param 3 - RTC_STRUCT pointer
 * @param 4 - PROF_STRUCT pointer
 */
__attribute__((mips16)) void RF_ProcessMsg(RF_STRUCT *rfData, MSGBUFF_STRUCT *msgBuffData, SYS_STRUCT *sysData, \
                                           RTC_DATA *rtcData, PROF_STRUCT *profData, ASTRO_STRUCT *astroData)
{ 
    
    uint8_t *buffPt;
    RFMSG_STRUCT *msgPt, *msgPtAux;                // Pointer for the message struct
    uint8_t crcCmp, ckSum, msgCmp=0;
    #if DEBUG_RF_RX_MSGPRINT
        uint8_t i;
    #endif        
        
    /* Initialise uint8_t pointer for the RF message structure */
    buffPt = &rfData->rxMsg;
    
    /* Initialise RFMSG_STRUCT pointer for the RF message structure */
    msgPt = &rfData->rxMsg;     
    
    /* Get the bytes received using the pointer for the RF Struct*/
    if (sysData->encCtrl == ENC_ON)
    {
        #ifdef RF_RFM22B
            crcCmp = RF_RFM22B_ReadRXfifo(buffMsg, &rfData->rxMsg.len);
        #endif
        #ifdef RF_RFM69HCW
            RF_RFM69HCW_ReadRXfifo(buffMsg, &rfData->rxMsg.len);
        #endif
        #ifdef RF_RFM95W
            RF_RFM95W_ReadRXfifo(buffMsg, &rfData->rxMsg.len);
        #endif
    }
    else
    {
        #ifdef RF_RFM22B
            crcCmp = RF_RFM22B_ReadRXfifo(buffPt, &rfData->rxMsg.len);
        #endif
        #ifdef RF_RFM69HCW
            RF_RFM69HCW_ReadRXfifo(buffPt, &rfData->rxMsg.len);
        #endif
        #ifdef RF_RFM95W
            RF_RFM95W_ReadRXfifo(buffPt, &rfData->rxMsg.len);
        #endif
    }                   
        
    /* If the message has bad CRC exit the function */
#ifdef RF_RFM22B
    if (crcCmp == 1)
    {
#endif 
#ifdef RF_RFM95W
    if ((RF_RFM95W_ReadReg(RF_REG_IRQ_FLAGS) & 0x50) == 0x50) // Verifies RX done and Valid Header and no CRC error
    {
#endif        
        /* Check if the system is in encryption mode */
        if (sysData->encCtrl == ENC_ON)
        {
            if ((rfData->rxMsg.len >= AES_BLOCK_SIZE) && (rfData->rxMsg.len <= MAX_RFMSG_LEN))
            {   
                /* Decrypt the message to be sent and get the length of the decrypted message */
                rfData->rxMsg.len = AES128_Decrypt(buffMsg, rfData->rxMsg.len, decrypt, &session_key);
            }
        }
        
        if ((rfData->rxMsg.len >= MIN_RFMSG_LEN) && (rfData->rxMsg.len <= MAX_RFMSG_LEN))
        {                        
            if (sysData->encCtrl == ENC_ON) 
            {
                #if DEBUG_RF_RX_MSGPRINT
                    UART_PrintString("\n\nRX Buff Decrypted: ");
                    for (i=0; i<rfData->rxMsg.len; i++)
                    {
                        sprintf(uart.txBuff,"%02X ", *(decrypt+i));
                        UART_PrintString(uart.txBuff);
                    }
                    UART_PrintString("\n\n");
                #endif
           
                memcpy(buffPt, decrypt, rfData->rxMsg.len);                
            }
            
            /* Fill the RF_Structure with the right values */
            rfData->rxMsg.ttl = rfData->rxMsg.data[rfData->rxMsg.len-HEADER-2];
            rfData->rxMsg.data[rfData->rxMsg.len-HEADER-2] = 0x00;

            rfData->rxMsg.cks = rfData->rxMsg.data[rfData->rxMsg.len-HEADER-1];
            rfData->rxMsg.data[rfData->rxMsg.len-HEADER-1] = 0x00;


            #if DEBUG_RF_RX_MSGPRINT
                UART_PrintString("\n\nRX Buff: ");
                for (i=0; i<rfData->rxMsg.len-2; i++)
                {
                    sprintf(uart.txBuff,"%02X ", *(buffPt+i));
                    UART_PrintString(uart.txBuff);
                }
                sprintf(uart.txBuff,"%02X %02X ", rfData->rxMsg.ttl, rfData->rxMsg.cks);
                UART_PrintString(uart.txBuff);
                UART_PrintString("\n\n");
            #endif
             
            /* Calculate the checksum of the msg received */
            ckSum = RF_CksCalc(msgPt);
            
            /* Check if the message is OK */
            if (ckSum == rfData->rxMsg.cks)
            {
                // Test if the message is equal to one of the last 3 messages
                if ((msgBuffData->ordID[0] == rfData->rxMsg.ordID) && (msgBuffData->msgID[0] == rfData->rxMsg.msgID) && (msgBuffData->net[0] == rfData->rxMsg.net))
                {
                    msgCmp = 0;
                }
                else if ((msgBuffData->ordID[1] == rfData->rxMsg.ordID) && (msgBuffData->msgID[1] == rfData->rxMsg.msgID) && (msgBuffData->net[1] == rfData->rxMsg.net))
                {
                    msgCmp = 0;
                }
                else if ((msgBuffData->ordID[2] == rfData->rxMsg.ordID) && (msgBuffData->msgID[2] == rfData->rxMsg.msgID) && (msgBuffData->net[2] == rfData->rxMsg.net))
                {
                    msgCmp = 0;
                }
                else
                {
                    /* The msg is different from last 3 msgs*/
                    msgCmp = 1;
                }

                /* To check if the message belongs to this RF protocol check the size of the message
                 * To maintain one single comparison we will put together the msgID and the length of the message
                 * then we compare the value */
                msgID_len = (rfData->rxMsg.msgID << 8) | rfData->rxMsg.len;


                #if DEBUG_RF_RX_MSGHANDLER
                    sprintf(uart.txBuff,"\nMsgCmp: %d | Cnt5s: %d | OrdIDAct: %d\n", msgCmp, rfData->cnt5s, msgBuff.ordIDact);
                    UART_PrintString(uart.txBuff);
                #endif


                //Checks if the 5s interval between msgs has passed in case of receiving the same msg
                if (((msgCmp == 0) && (rfData->cnt5s == 0)) || (msgCmp > 0))
                {
                    /* Save the parameters of last valid message */
                    msgBuffData->ordID[msgBuffData->ind] = rfData->rxMsg.ordID;
                    msgBuffData->msgID[msgBuffData->ind] = rfData->rxMsg.msgID;
                    msgBuffData->net[msgBuffData->ind] = rfData->rxMsg.net;

                    /* Update the index of the circular buffer */
                    msgBuffData->ind++;
                    if (msgBuffData->ind > 2)
                        msgBuffData->ind = 0;

                    /* The current Order ID should be saved, for the ans/ack msgs */
                    msgBuffData->ordIDact = rfData->rxMsg.ordID;

                    /* Check if is a debug/technical message */
                    if (rfData->rxMsg.ordID == DEBUG_ORD_ID)
                    {
                        if (msgID_len == ASK_WHOIS)
                        {
                            rfData->msgIDsend = ANS_WHOIS;                            
                        }
                        else if ((rfData->rxMsg.net == sysData->net) && (rfData->rxMsg.sn == sysData->sn))
                        {
                            switch(msgID_len)
                            {
                                case ASK_WHAT_CLK:
                                    
                                    rfData->msgIDsend = ANS_WHAT_CLK;
                                    break;

                                case CONF_ENC:

                                    /* The Encryption will be set in the SYS_Update() Function
                                     * Save to memory and the in the SYS_Update function set in the sys structure */
                                    RTC_MCP7952x_WrtEEPROM_Byte(ENC_ADD, rfData->rxMsg.data[0]);
                                    rfData->msgIDsend = ACK_CONF_ENC;                                
                                    break;

                                default:
                                    break;
                            }
                            
                        } // END if (msgID_len == ASK_WHOIS)  
                        
                    }
                    /* Network config message - Don't have the length of the message, it's compared separately */
                    else if ((rfData->rxMsg.msgID == CONF_NET) && (rfData->rxMsg.sn == sysData->sn) && (rfData->rxMsg.len == CONF_NET_LEN))
                    {
                        sysData->net = rfData->rxMsg.net;
                        
                        /* Save to EEPROM the new network number */
                        buffPt = &sysData->net;
                        RTC_MCP7952x_WrtEEPROM_Array(NET_ADD, buffPt, 2);

                        /* Send ACK */
                        rfData->msgIDsend = ACK_CONF_NET;

                        /* Update Initial configs for Stability sensor & Config maximum current */
                        sysData->updateID = UPDATE_SYS_CONFIG;

                    } //END if ((rfData->rxMsg.msgID == CONF_NET) && (rfData->rxMsg.sn == sysData->sn))
                    else if ((rfData->rxMsg.net == sysData->net) && ((rfData->rxMsg.sn == sysData->sn) || (rfData->rxMsg.sn == BROADCAST)))	//Check if the message is for this device
                    {
                        switch(msgID_len)
                        {
                            /* RTC UPDATE MESSAGE - Broadcast */
                            case CAL_UPDATE:

                                memcpy(rtcData, rfData->rxMsg.data, RTC_DATA_SIZE);

                                /* If it is Unicast msg send ACK*/
                                if (rfData->rxMsg.sn != BROADCAST)
                                {
                                    rfData->msgIDsend = ACK_CAL_UPDATE;
                                }

                                /* The flag indicates the RTC Update */
                                sysData->updateID = RTC_UPDATE;

                                break;

                            //PROFILE CONFIG MESSAGE - Broadcast/Unicast
                            case CONF_PROFILE:

                                memcpy(profData, rfData->rxMsg.data, PROF_SIZE);

                                /* If it is Unicast msg send ACK*/
                                if (rfData->rxMsg.sn != BROADCAST)
                                {
                                    rfData->msgIDsend = ACK_CONF_PROFILE;
                                }

                                /* The flag indicates the profile Update */
                                sysData->updateID = PROF_UPDATE;

                                break;

                            //ASK PROFILE MESSAGE - Unicast
                            case ASK_PROFILE:

                                rfData->msgIDsend = ANS_PROFILE;

                                break;

                            //CONFIG ASTRONOMICAL CLOCK - Unicast/Broadcast
                            case CONF_ASTOCLK:

                                memcpy(astroData, rfData->rxMsg.data, ASTROCLK_DATA_LEN);

                                /* If it is Unicast msg send ACK*/
                                if (rfData->rxMsg.sn != BROADCAST)
                                {
                                    rfData->msgIDsend = ACK_CONF_ASTOCLK;
                                }

                                /* The flag indicates the astronomical clock confs. update */
                                sysData->updateID = ASTRO_UPDATE;

                                break;

                            //PWM CONTROL MESSAGE - Broadcast/Unicast
                            case CONF_PWM:

                                /* Config the new Duty-cycle - Have to be converted
                                 * Use the state-machine variable, to work properly with alarm control */
                                sysData->dtSttMch = PERCENT_TO_DUTY(rfData->rxMsg.data[0]);

                                // Check if it's a Unicast msg
                                if (rfData->rxMsg.sn != BROADCAST)
                                {
                                    // Send ACK
                                    rfData->msgIDsend = ACK_CONF_PWM;
                                }

                                //Flag for new duty-cycle set-up
                                sysData->flagDim = 1;

                                /* Save the new dimming to EEPROM */
                                buffPt = &sysData->dtSttMch;
                                RTC_MCP7952x_WrtEEPROM_Array(DUTY_TMP_ADD, buffPt, 2);

                                break;

                            //GENRERAL CONFIGS MESSAGE - Broadcast/Unicast
                            case CONF_GENERAL:

                                /* Check if it is a SOS state change - If yes only change the sysStt variable */
                                if ((sysData->sysStt == SYS_SOS) || (rfData->rxMsg.data[0] == SYS_SOS))
                                {
                                    sysData->sysStt = rfData->rxMsg.data[0];
                                    RTC_MCP7952x_WrtEEPROM_Byte(SYS_STT_ADD, sysData->sysStt);
                                }
                                else
                                {
                                    /* Copy configurations to SYS_STRUCT */
                                    buffPt = &sysData->sysStt;
                                    memcpy(buffPt, rfData->rxMsg.data, CONF_SIZE);

                                    /* The flag indicates the profile Update */
                                    sysData->updateID = CONFIGS_UPDATE;
                                }

                                /* If it is Unicast msg send ACK*/
                                if (rfData->rxMsg.sn != BROADCAST)
                                    rfData->msgIDsend = ACK_CONF_GENERAL;

                                break;

                            //ASK TELEMETRY MESSAGE - Unicast
                            case ASK_TELEM_EXT:
                                
                                if (rfData->rxMsg.sn != BROADCAST)
                                {
                                    /* Reply to the request */
                                    
                                    rfData->msgIDsend = ANS_TELEM_EXT;
                                }

                                break;

                            //ADDITIONAL CONFIGURATIONS MESSAGE - Broadcast/Unicast
                            case CONF_ADDON:

                                /* Set the new configurations */
                                sysData->debugCtrl = rfData->rxMsg.data[0];
                                sysData->pirENABLE = rfData->rxMsg.data[1];
                                sysData->tLedENABLE = rfData->rxMsg.data[2];
                                sysData->dutyFact = (double)(rfData->rxMsg.data[3]) / 100.0;    /* Convert from 0-100 to 0.0 to 1.0 */

                                if ((sysData->dutyFact > 1.0) || (sysData->dutyFact < 0.1))
                                    sysData->dutyFact = 1.0;
                                
                                /* If it is Unicast msg send ACK*/
                                if (rfData->rxMsg.sn != BROADCAST)
                                {
                                    rfData->msgIDsend = ACK_CONF_ADDON;
                                }

                                /* The flag indicates the Update ID - Save the new configurations in EEPROM */
                                sysData->updateID = ADDON_CONFIGS_UPDATE;

                                break;

                            case SYS_TOTALTEL:

                                if (rfData->rxMsg.sn != BROADCAST)
                                {
                                    /* Reply to the request */
                                    rfData->msgIDsend = ANS_SYS_TOTALTEL;
                                }

                                break;

                            //PIR CONTROL MESSAGE - Broadcast
                            case PIR_CONTROL:

                                sys.pirCtrl = rfData->rxMsg.data[0];

                                break;

                            case LDR_CONTROL:

                                /* If there is no local LDR sensor installed accept the LDR information */
                                if (sysData->ldrS.inFlag == DISABLE)
                                {
                                    memcpy(&sysData->ldr, rfData->rxMsg.data, UINT16_SIZE);
                                    sysData->ldrS.ldrDuty = rfData->rxMsg.data[2];
                                    sysData->ldrS.ready = 1;
                                    sysData->flag1min = 1; // Forces 1 minute check for imediate value attribution
                                }

                                break;
                                
                            case CONF_SENSORS:
                                                               
                                memcpy(&quadratic_AN1, &rfData->rxMsg.data[1], 4);
                                memcpy(&slope_AN1, &rfData->rxMsg.data[5], 4);
                                memcpy(&intercept_AN1, &rfData->rxMsg.data[9], 4);
                                
                                if (rfData->rxMsg.sn != BROADCAST)
                                {
                                    // Send ACK
                                    rfData->msgIDsend = ACK_CONF_SENSORS;
                                }
                                
                                sysData->updateID = CONFIG_SENSORS_UPDATE;
                                
                                break;

                            default:
                                #if DEBUG_WRONG_MSG
                                    UART_PrintString("\nWrong ID/Length!\n");
                                #endif

                                break;
                        }


                        //If is a broadcast message - re-sends the message
                        if ((rfData->rxMsg.sn == BROADCAST) && (rfData->rxMsg.ttl < sys.ttlMAX))
                        {
                            #if DEBUG_RESEND_RF
                            UART_PrintString("\nRe-Send Broadcast message!\n");
                            #endif

                            /* fill the tx buffer to re-send the message */
                            msgPtAux = &rfData->txMsg;
                            memcpy(msgPtAux, msgPt, rfData->rxMsg.len-2);     /* Copy the header and data */

                            /* For each forwarding increase TTL */
                            rfData->txMsg.ttl = rfData->rxMsg.ttl + 1;

                            rfData->txMsg.len = rfData->rxMsg.len;

                            //Re-send message
                            rfData->msgIDsend = RE_SEND;
                        }

                    } //END if ((rfData->rxMsg.net == sysData->net) && ((rfData->rxMsg.sn == sysData->sn) || (rfData->rxMsg == BROADCAST)))
                    else if (rfData->rxMsg.ttl < sys.ttlMAX)
                    {
                        //If msg hasn´t the same serial or network re-sends to the others

                        /* fill the tx buffer to re-send the message */
                        msgPtAux = &rfData->txMsg;
                        memcpy(msgPtAux, msgPt, rfData->rxMsg.len-2);     /* Copy the header and data */

                        /* For each forwarding increase TTL */
                        rfData->txMsg.ttl = rfData->rxMsg.ttl + 1;

                        rfData->txMsg.len = rfData->rxMsg.len;

                        //Re-send message
                        rfData->msgIDsend = RE_SEND;
                    }

                    #if DEBUG_RCV_RF
                    UART_PrintString("\nMsg received\n");
                    #endif

                    //Start 5s counter
                    rfData->cnt5s = 1;

                } //END if (((msgCmp == 0) && (rfData->cnt5s == 0)) || (msgCmp != 0))
                #if DEBUG_RF_5S
                else
                {
                    UART_PrintString("\nMsg, t < 5s\n");
                }
                #endif

            } //END if ( (crcCmp == 1) && (ckSum == rfData->rxMsg.cks) )
            #if DEBUG_RF_ERROR
            else
            {
                UART_PrintString("\nERROR receiving RF msg!\n");
            }
            #endif


        } // END if ((rfData->rxMsg.len > MIN_RFMSG_LEN) && (rfData->rxMsg.len <= MAX_RFMSG_LEN))
        
#ifdef RF_RFM22B
    } // END if (crcCmp == 1)
#endif
#ifdef RF_RFM95W 
    }
#endif  
    
    /* Clear RX Buffer to avoid errors in the next received message*/
    RF_ClrMsg(msgPt);
  
    /* Clear encryption buffer */
    SYS_ClearBuff(decrypt, MAX_RFMSG_LEN);
    SYS_ClearBuff(buffMsg, MAX_RFMSG_LEN);    
}


/**
 * Function to send a RF message
 * @param 1 - RF_STRUCT pointer
 * @param 2 - SYS_STRUCT pointer
 * @param 3 - RTC_STRUCT pointer
 * @param 4 - PROF_STRUCT pointer
 * @param 5 - ALARM_STRUCT pointer
 * @param 6 - PWR_CONSUME_STRUCT pointer
 */
__attribute__((mips16)) void RF_SendMsg(RF_STRUCT *rfData, MSGBUFF_STRUCT *msgBuffData, SYS_STRUCT *sysData, RTC_DATA *rtcData,\
                                        PROF_STRUCT *profData, ALARM_STRUCT *alrData, PWR_CONSUME_STRUCT *pwrData, PM_STRUCT *pmData)
{
    RFMSG_STRUCT *txMsgPt;
    uint8_t *buffPt;
    uint8_t rndDly=0, dly=0;
    uint8_t newLen;
#if DEBUG_SEND_RF_MSG
    uint8_t i;
#endif

    /* Change RF-State to Ready Mode/Standby Mode - disable reception of new messages */
    #ifdef RF_RFM22B
        RF_RFM22B_ReadyMode();    
    #endif
    #ifdef RF_RFM69HCW
        RF_RFM69HCW_StandbyMode();
    #endif
    #ifdef RF_RFM95W
        RF_RFM95W_StandbyMode();
    #endif  
    
    /* Initialise pointer for message */
    txMsgPt = &rfData->txMsg;

    /* Set Order ID and Msg ID */
    rfData->txMsg.ordID = msgBuffData->ordIDact;

    
    if (rfData->msgIDsend == RE_SEND)
    {
        //The message was copied ant the TTL set in processRf() function

        /* Set the values for the delays */
        rndDly = RE_SEND_RND_DLY;
        dly = RE_SEND_DLY;
    }
    else
    {
        // Write the network (NET+SN) header to the tx buffer
        rfData->txMsg.sn = sysData->sn;
        rfData->txMsg.net = sysData->net;

        // Set TTL byte to 1
        rfData->txMsg.ttl = 1;

        switch(rfData->msgIDsend)
        {
            case ACK_CONF_NET:
                
                /* Set the corresponding ID and OK byte */
                rfData->txMsg.msgID = ACK_CONF_NET;
                rfData->txMsg.data[0] = OK_MSG;

                /* Set length of the RF message */
                rfData->txMsg.len = ACK_CONF_NET_LEN;

                /* Set the values for the delays */
                rndDly = ACK_ANS_RND_DLY;
                dly = ACK_ANS_DLY;

                break;

            case ACK_CAL_UPDATE:

                /* Set the corresponding ID and OK byte */
                rfData->txMsg.msgID = ACK_CAL_UPDATE;
                rfData->txMsg.data[0] = OK_MSG;

                /* Set length of the RF message */
                rfData->txMsg.len = ACK_CAL_UPDATE_LEN;

                /* Set the values for the delays */
                rndDly = ACK_ANS_RND_DLY;
                dly = ACK_ANS_DLY;

                break;

            case ACK_CONF_PROFILE:

                /* Set the corresponding ID and OK byte */
                rfData->txMsg.msgID = ACK_CONF_PROFILE;
                rfData->txMsg.data[0] = OK_MSG;

                /* Set length of the RF message */
                rfData->txMsg.len = ACK_CONF_PROFILE_LEN;

                /* Set the values for the delays */
                rndDly = ACK_ANS_RND_DLY;
                dly = ACK_ANS_DLY;

                break;

            case ANS_PROFILE:

                /* Set the corresponding ID */
                rfData->txMsg.msgID = ANS_PROFILE;

                /* Write the profile configurations to the buffer */
                memcpy(rfData->txMsg.data, profData, PROF_SIZE);

                /* Set length of the RF message */
                rfData->txMsg.len = ANS_PROFILE_LEN;

                /* Set the values for the delays */
                rndDly = ACK_ANS_RND_DLY;
                dly = ACK_ANS_DLY;

                break;

            case ACK_CONF_ASTOCLK:

                /* Set the corresponding ID and OK byte */
                rfData->txMsg.msgID = ACK_CONF_ASTOCLK;
                rfData->txMsg.data[0] = OK_MSG;

                /* Set length of the RF message */
                rfData->txMsg.len = ACK_CONF_ASTOCLK_LEN;

                /* Set the values for the delays */
                rndDly = ACK_ANS_RND_DLY;
                dly = ACK_ANS_DLY;

                break;

            case ACK_CONF_PWM:

                /* Set the corresponding ID and OK byte */
                rfData->txMsg.msgID = ACK_CONF_PWM;
                rfData->txMsg.data[0] = OK_MSG;

                /* Set length of the RF message */
                rfData->txMsg.len = ACK_CONF_PWM_LEN;

                /* Set the values for the delays */
                rndDly = ACK_ANS_RND_DLY;
                dly = ACK_ANS_DLY;

                break;

            case ACK_CONF_GENERAL:

                 /* Set the corresponding ID and OK byte */
                rfData->txMsg.msgID = ACK_CONF_GENERAL;
                rfData->txMsg.data[0] = OK_MSG;

                /* Set length of the RF message */
                rfData->txMsg.len = ACK_CONF_GENERAL_LEN;

                /* Set the values for the delays */
                rndDly = ACK_ANS_RND_DLY;
                dly = ACK_ANS_DLY;

                break;

            case ANS_TELEM_EXT:
                
                 /* Set the corresponding ID */
                rfData->txMsg.msgID = ANS_TELEM_EXT;
                
                /* Write telemetry information to the buffer */
                //buffPt = sysData;
                memcpy(rfData->txMsg.data + 0, &v1, DOUBLE_SIZE);
                memcpy(rfData->txMsg.data + 4, &v2, DOUBLE_SIZE);
                memcpy(rfData->txMsg.data + 8, &v3, DOUBLE_SIZE);
                memcpy(rfData->txMsg.data + 12, &i1, DOUBLE_SIZE);
                memcpy(rfData->txMsg.data + 16, &i2, DOUBLE_SIZE);
                memcpy(rfData->txMsg.data + 20, &i3, DOUBLE_SIZE);
                memcpy(rfData->txMsg.data + 24, &fp1, 2);
                memcpy(rfData->txMsg.data + 26, &fp2, 2);
                memcpy(rfData->txMsg.data + 28, &fp3, 2);
                memcpy(rfData->txMsg.data + 30, &kwhSum, DOUBLE_SIZE); 
                
                /* Set length of the RF message */
                rfData->txMsg.len = ANS_TELEM_ENERGY_LEN_2;
                
                /* Set the values for the delays */
                rndDly = ACK_ANS_RND_DLY;
                dly = ACK_ANS_DLY;
                
                break;
                
#ifndef POWER_METER
                memset(&sysData->current, 0xFF, UINT16_SIZE);
#endif
                memcpy(rfData->txMsg.data, buffPt+NET_HEADER, TELEM_DATA_LEN);

                /* Write the PWM value */
                rfData->txMsg.data[TELEM_DATA_LEN] = DUTY_TO_PERCENT(sysData->dutyTmp);

                /* Write the Power consumption */
#ifdef POWER_METER
                buffPt = &pwrData->kwhSum;
                memcpy(rfData->txMsg.data+TELEM_KWH_POS, buffPt, DOUBLE_SIZE);
#else
                memset(rfData->txMsg.data+TELEM_KWH_POS, 0xFF, DOUBLE_SIZE);
#endif
                /* Set length of the RF message */
                //rfData->txMsg.len = ANS_TELEM_EXT_LEN;
                rfData->txMsg.len = ANS_TELEM_ENERGY_LEN_2;

                /* Set the values for the delays */
                rndDly = ACK_ANS_RND_DLY;
                dly = ACK_ANS_DLY;

                break;

            case ACK_CONF_ADDON:

                 /* Set the corresponding ID */
                rfData->txMsg.msgID = ACK_CONF_ADDON;
                rfData->txMsg.data[0] = OK_MSG;

                /* Set length of the RF message */
                rfData->txMsg.len = ACK_CONF_ADDON_LEN;

                /* Set the values for the delays */
                rndDly = ACK_ANS_RND_DLY;
                dly = ACK_ANS_DLY;

                break;

            case ANS_SYS_TOTALTEL:

                //Set the corresponding ID
                rfData->txMsg.msgID = ANS_SYS_TOTALTEL;

                // Write the totalisers data to the buffer
                //buffPt = &pwrData->kwhSum;
                buffPt = &pwrData->kw;                                   /* Write kW and kVAr */
                memcpy(rfData->txMsg.data, buffPt, TOTALIZERS_DATA_LEN);

                rfData->txMsg.len = ANS_SYS_TOTALTEL_LEN;

                //DEBUG
                ///////////////////////////////////////////////////
                //rfData->txMsg.ordID = 0x01;

                //buffPt = &pmData->curr;
                //buffPt = &pmData->debugBuff[0];
                //memcpy(rfData->txMsg.data, buffPt, PM_DATAREAD_LEN);
                //memcpy(rfData->txMsg.data, buffPt, PM_BYTES_TO_READ);
                //memcpy(rfData->txMsg.data, buffPt, rfData->txMsg.len-8);

                //rfData->txMsg.len = 18;
                ///////////////////////////////////////////////////

                // Set the valuse for the delays
                rndDly = ACK_ANS_RND_DLY;
                dly = ACK_ANS_DLY;

                break;

            case PIR_CONTROL_SEND:

                /* Re-Set Order ID */
                rfData->txMsg.ordID = 0x01;

                /* Re-Set Serial Number - Broadcast Message */
                rfData->txMsg.sn = 0xFFFF;

                /* Set the corresponding ID */
                rfData->txMsg.msgID = PIR_CONTROL_SEND;

                /* rite the PIR state to the buffer */
                rfData->txMsg.data[0] = sysData->pirCtrl;

                /* Set length of the RF message */
                rfData->txMsg.len = PIR_CONTROL_LEN;

                break;

            case LDR_CONTROL_SEND:

                /* Re-Set Order ID */
                rfData->txMsg.ordID = 0x01;

                /* Re-Set Serial Number - Broadcast Message */
                rfData->txMsg.sn = 0xFFFF;

                /* Set the corresponding ID */
                rfData->txMsg.msgID = LDR_CONTROL_SEND;

                /* Write the LDR value to the buffer */
                buffPt = &sysData->ldr;
                memcpy(rfData->txMsg.data, buffPt, UINT16_SIZE);
                rfData->txMsg.data[2] = DUTY_TO_PERCENT(sysData->dtSttMch);
                
                /* Set length of the RF message */
                rfData->txMsg.len = LDR_CONTROL_LEN;

                break;

            case ALARM_MSG:

                /* Re-Set Order ID */
                rfData->txMsg.ordID = 0x01;

                /* Set the corresponding ID */
                rfData->txMsg.msgID = ALARM_MSG;

                /* Write alarm information to the buffer */
                rfData->txMsg.data[ALR_LAMP] = (alrData->resume >> LAMP_POS) & 0x01;
                rfData->txMsg.data[ALR_TEMPLAMP] = (alrData->resume >> TEMPLAMP_POS) & 0x01;
                rfData->txMsg.data[ALR_TEMPPCB] = (alrData->resume >> TEMPPCB_POS) & 0x01;
                rfData->txMsg.data[ALR_STAB] = (alrData->resume >> STAB_POS) & 0x01;
                rfData->txMsg.data[ALR_CURR] = (alrData->resume >> CURR_POS) & 0x01;
                rfData->txMsg.data[ALR_VOLT] = (alrData->resume >> VOLT_POS) & 0x01;
                rfData->txMsg.data[ALR_LDR] = (alrData->resume >> LDR_POS) & 0x01;

                /* Set length of the RF message */
                rfData->txMsg.len = ALARM_MSG_LEN;

                break;

            case ANS_WHOIS:

                /* Set the respective Order ID for the answer to DEBUG messages */
                rfData->txMsg.ordID = DEBUG_ORD_ID;

                /* Set the corresponding ID */
                rfData->txMsg.msgID = ANS_WHOIS;

                //Send the value off the RSSI (msg received)
                rfData->txMsg.data[0] = rfData->rssiVal;

                /* Set length of the RF message */
                rfData->txMsg.len = ANS_WHOIS_LEN;

                rndDly = DEBUG_RND_DLY;
                dly = DEBUG_DLY;

                break;

            case ANS_WHAT_CLK:

                /* Set the respective Order ID for the answer to DEBUG messages */
                rfData->txMsg.ordID = DEBUG_ORD_ID;
                
                /* Set the corresponding ID */
                rfData->txMsg.msgID = ANS_WHAT_CLK;

                //Write the rtc values in the buffer
                memcpy(rfData->txMsg.data, rtcData, RTC_DATA_SIZE);

                /* Set length of the RF message */
                rfData->txMsg.len = ANS_WHAT_CLK_LEN;

                /* Set the valuse for the delays */
                rndDly = DEBUG_RND_DLY;
                dly = DEBUG_DLY;

                break;
             
            case ACK_CONF_ENC:
                
                /* Set the respective Order ID for the answer to DEBUG messages */
                rfData->txMsg.ordID = DEBUG_ORD_ID;
                
                /* Set the corresponding ID */
                rfData->txMsg.msgID = ACK_CONF_ENC;                
                rfData->txMsg.data[0] = OK_MSG;
                
                /* Set length of the RF message */
                rfData->txMsg.len = ACK_CONF_ENC_LEN;

                /* Set the value for the delays */
                rndDly = DEBUG_RND_DLY;
                dly = DEBUG_DLY;

                /* Set order to configure the Encryption setting */
                sysData->updateID = ENCRYPTION_UPDATE;
                
                break;
                
            case ACK_CONF_SENSORS:
                
                /* Set the corresponding ID and OK byte */
                rfData->txMsg.msgID = ACK_CONF_SENSORS;
                rfData->txMsg.data[0] = OK_MSG;

                /* Set length of the RF message */
                rfData->txMsg.len = ACK_CONF_SENSORS_LEN;

                /* Set the values for the delays */
                rndDly = ACK_ANS_RND_DLY;
                dly = ACK_ANS_DLY;
                
                break;
                
            default:
                break;

        } // END switch(rfData->msgIDsend)

    }

    /* Calculation of the checksum */
    rfData->txMsg.cks = RF_CksCalc(txMsgPt);


    /*********************/
    /*    Send RF msg    */
    /*********************/
    if ((rfData->msgIDsend != PIR_CONTROL_SEND) && (rfData->msgIDsend != LDR_CONTROL_SEND) && (rfData->msgIDsend != ALARM_MSG))
    {
        delayMs((rand() % rndDly) + dly);
    }

    #if DEBUG_SEND_RF_MSG
        buffPt = txMsgPt;
        UART_PrintString("\n\nTX Buff: ");
        for (i=0; i<rfData->txMsg.len-2; i++)
        {
            sprintf(uart.txBuff,"%02X ", *(buffPt+i));
            UART_PrintString(uart.txBuff);
        }
        sprintf(uart.txBuff,"%02X %02X ", rfData->txMsg.ttl, rfData->txMsg.cks);
        UART_PrintString(uart.txBuff);
        UART_PrintString("\n\n");
    #endif

    /* Create a continuous buffer for the message to be sent - Header+Data+TTL+CKS */
    buffPt = txMsgPt;
    memcpy(buffMsg, buffPt, txMsgPt->len-2);     /* Copy the header and data */

    buffMsg[txMsgPt->len-2] = txMsgPt->ttl;         /* Copy the ttl */
    buffMsg[txMsgPt->len-1] = txMsgPt->cks;         /* Copy the cks */
   
   
    if (sysData->encCtrl == ENC_ON)
    {            
        /* Encrypt the message to be sent */
        newLen = AES128_Encrypt(buffMsg, txMsgPt->len, encrypt, &session_key);
    
        /* Write message to RF FIFO and start transmission */
        #ifdef RF_RFM22B
            RF_RFM22B_WrtTXfifo(encrypt, newLen);
        #endif
        #ifdef RF_RFM69HCW
            RF_RFM69HCW_WrtTXfifo(encrypt, newLen);
        #endif
        #ifdef RF_RFM95W
            RF_RFM95W_WrtTXfifo(encrypt, newLen);
        #endif
    }
    else
    {
        /* Write message to RF FIFO and start transmission */ 
        #ifdef RF_RFM22B
            RF_RFM22B_WrtTXfifo(buffMsg, txMsgPt->len);
        #endif
        #ifdef RF_RFM69HCW
            RF_RFM69HCW_WrtTXfifo(buffMsg, txMsgPt->len);   
        #endif
        #ifdef RF_RFM95W
            RF_RFM95W_WrtTXfifo(buffMsg, txMsgPt->len);   
        #endif  
    }    

    rfData->msgSent = 1;                        /* set message sent change of the RF-state */

    /* wait cycle */
    #ifdef RF_RFM22B
        delayMs(10);
    #endif
    #ifdef RF_RFM69HCW
        delayMs(5);    
    #endif
    #ifdef RF_RFM95W
        delayMs(5);    
    #endif

    //----------------------------------------//

    if (rfData->msgIDsend != RE_SEND)
    {
        /* Save the parameters of the last valid message - The message is only sent once
         If is RE_SEND order, the parameters was already saved */
        msgBuffData->ordID[msgBuffData->ind] = rfData->txMsg.ordID;
        msgBuffData->msgID[msgBuffData->ind] = rfData->txMsg.msgID;
        msgBuffData->net[msgBuffData->ind] = rfData->txMsg.net;

        /* Update the index of the circular buffer */
        msgBuffData->ind++;

        if (msgBuffData->ind > 2)
            msgBuffData->ind = 0;
    }

    /* Clear RX Buffer to avoid errors in the next received message */
    RF_ClrMsg(txMsgPt);
  
    /* Clear encryption buffer */
    SYS_ClearBuff(encrypt, sizeof(encrypt));
    
    /* Start 5s counter */
    rfData->cnt5s = 1;

}


#ifdef RF_RFM22B
/**
 * Function to implement the State-Machine for the RF communication
 * @param 1 - RF_STRUCT pointer
 * @param 2 - SYS_STRUCT pointer
 * @param 3 - RTC_STRUCT pointer
 * @param 4 - PROF_STRUCT pointer
 */
__attribute__((mips16)) void RF_RFM22B_SttMachine(RF_STRUCT *rfData, MSGBUFF_STRUCT *msgBuffData, SYS_STRUCT *sysData, \
                                                  RTC_DATA *rtcData, PROF_STRUCT *profData, ASTRO_STRUCT *astroData, PM_STRUCT *pmData)
{
    /* Disable rf interrupts to avoid more interrupts */
    RF_RFM22B_DisRfInt();
    RF_RFM22B_ClrRfInt();

    /* Check if a message has been sent*/
    if (rfData->msgSent == 1)
    {
        RF_RFM22B_RxMode();         /* Switch to RX Mode */
        rfData->msgSent = 0;
    }
    else
    {
        /* The interruption was caused by a reception of a new msg */        
        rfData->msgRcv = 1;     /* Flag for the control of RF Crash */

        /* Check the RSSI */
        rfData->rssiVal = RF_RFM22B_GetRSSI();

        /* Disable the reception of messages */
        RF_RFM22B_ReadyMode();

        /* Handling of the message received */
        RF_ProcessMsg(rfData, msgBuffData, sysData, rtcData, profData, astroData);
        RF_RFM22B_RxMode();          /* Switch back to RX Mode */
    }

    /* Enable RF interrupts */
    RF_RFM22B_EnRfInt();
}
#endif
#ifdef RF_RFM69HCW
/**
 * Function to implement the State-Machine for the RF communication
 * @param 1 - RF_STRUCT pointer
 * @param 2 - SYS_STRUCT pointer
 * @param 3 - RTC_STRUCT pointer
 * @param 4 - PROF_STRUCT pointer
 */
__attribute__((mips16)) void RF_RFM69HCW_SttMachine(RF_STRUCT *rfData, MSGBUFF_STRUCT *msgBuffData, SYS_STRUCT *sysData, \
                                                    RTC_DATA *rtcData, PROF_STRUCT *profData, ASTRO_STRUCT *astroData)
{   
    //#ifdef DEBUG_RF_INTERROR
    //    UART_PrintString("\n RF Int detected! \n");
    //#endif       
        
    /* Set Standby Mode to avoid more interruptions */
    RF_RFM69HCW_StandbyMode();    
    
    /* Check if a message has been sent*/
    if (rfData->msgSent == 1)
    {
        //#ifdef DEBUG_RF_INTERROR
        //    UART_PrintString("\n RF msg sent! \n");
        //#endif

        rfData->msgSent = 0;
    }
    else
    {
        //#ifdef DEBUG_RF_INTERROR
         //   UART_PrintString("\n RF msg received! \n");
       // #endif
            
        /* The interruption was caused by a reception of a new msg */        
        rfData->msgRcv = 1;     /* Flag for the control of RF Crash */

        /* Handling of the message received */
        RF_ProcessMsg(rfData, msgBuffData, sysData, rtcData, profData, astroData);
    }    
    
    /* Switch back to RX Mode */
    RF_RFM69HCW_RxMode();
    
    /* Wait to enter in RX Mode */
    delayMs(2);    
}
#endif
#ifdef RF_RFM95W
/**
 * Function to implement the State-Machine for the RF communication
 * @param 1 - RF_STRUCT pointer
 * @param 2 - SYS_STRUCT pointer
 * @param 3 - RTC_STRUCT pointer
 * @param 4 - PROF_STRUCT pointer
 */
__attribute__((mips16)) void RF_RFM95W_SttMachine(RF_STRUCT *rfData, MSGBUFF_STRUCT *msgBuffData, SYS_STRUCT *sysData, \
                                                    RTC_DATA *rtcData, PROF_STRUCT *profData, ASTRO_STRUCT *astroData)
{   
    /* Set Standby Mode to avoid more interruptions */    
    RF_RFM95W_StandbyMode();  
    
    #ifdef DEBUG_RF_INTERROR
        UART_PrintString("\n RF Int detected! \n");
        sprintf(uart.txBuff,"\r\nIRQ FLAGS = %x | NO BYTES = %d | LAST BYTE ADDR = %x\r\n", \
        RF_RFM95W_ReadReg(RF_REG_IRQ_FLAGS),RF_RFM95W_ReadReg(RF_REG_RX_NB_BYTES),RF_RFM95W_ReadReg(RF_REG_FIFO_CURR_ADDR)); 
        UART_PrintString(uart.txBuff);
        
    #endif  
          
    /* Check if a message has been sent*/
    if (rfData->msgSent == 1)
    {
        #ifdef DEBUG_RF_INTERROR
            UART_PrintString("\n RF msg sent! \n");
        #endif

        rfData->msgSent = 0;
    }
    else
    {
        #ifdef DEBUG_RF_INTERROR
            UART_PrintString("\n RF msg received! \n");
        #endif
            
        /* The interruption was caused by a reception of a new msg */        
        rfData->msgRcv = 1;     /* Flag for the control of RF Crash */

        /* Handling of the message received */
        RF_ProcessMsg(rfData, msgBuffData, sysData, rtcData, profData, astroData);
    }    
    
    /* Switch back to RX Mode */
    RF_RFM95W_RxMode();
    
    /* Wait to enter in RX Mode */
    delayMs(2);     
}
#endif


#ifdef RF_RFM22B
/**
 * Function to Set a Software Reset on the RF module
 * @param 1 - RF_STRUCT pointer
 */
void RF_RFM22B_Reset(RF_STRUCT *rfData)
{    
#if DEBUG_RF_RESET
    UART_PrintString("\nReset Sequence Started!\n");
#endif

    /* Disable interrupts and set RF Interrupt flag to zero */
    RF_RFM22B_DisRfInt();
    rfData->int_RF = 0;
        
    /* Set Software Reset and wait 1ms> */
    RF_RFM22B_SetSoftRESET();    
    delayMs(10);

    /* Initial RF Configurations */   
    RF_RFM22B_Config();
    
    /* Clear RF flags */
    rfData->int_RF = 0;
    rfData->msgRcv = 0;
    rfData->msgSent = 0;
    
#if DEBUG_RF_RESET
    UART_PrintString("\nEnd of Reset Sequence!\n");
#endif
}
#endif
#ifdef RF_RFM69HCW
/**
 * Function to Set a Software Reset on the RF module
 * => Once there is no softreset registor, the only thing that it is possible,
 *    is to reconfigure and change the RF State of the module
 * @param 1 - RF_STRUCT pointer
 */
void RF_RFM69HCW_Reset(RF_STRUCT *rfData)
{
#if DEBUG_RF_RESET
    UART_PrintString("\nReset Sequence Started!\n");
#endif
    
    /* Set RF Interrupt flag to zero */
    rfData->int_RF = 0;
    
    /* Reonfigure the RF module*/
    RF_RFM69HCW_Config();
    
    /* Change RF Module to restart the receiving stage */
    RF_RFM69HCW_ChgStt();
    
    /* Clear RF flags */
    rfData->int_RF = 0;
    rfData->msgRcv = 0;
    rfData->msgSent = 0;
    
#if DEBUG_RF_RESET
    UART_PrintString("\nEnd of Reset Sequence!\n");
#endif    
}
#endif
#ifdef RF_RFM95W
/**
 * Function to Set a Software Reset on the RF module
 * => Once there is no softreset registor, the only thing that it is possible,
 *    is to reconfigure and change the RF State of the module
 * @param 1 - RF_STRUCT pointer
 */
void RF_RFM95W_Reset(RF_STRUCT *rfData)
{
#if DEBUG_RF_RESET
    UART_PrintString("\nReset Sequence Started!\n");
#endif
    
    /* Set RF Interrupt flag to zero */
    rfData->int_RF = 0;
    
    /* Reonfigure the RF module*/
    RF_RFM95W_Config();
   
    /* Clear RF flags */
    rfData->int_RF = 0;
    rfData->msgRcv = 0;
    rfData->msgSent = 0;
    
#if DEBUG_RF_RESET
    UART_PrintString("\nEnd of Reset Sequence!\n");
#endif    
}
#endif

/**
 * Function to clear the RF buffer
 */
__attribute__((mips16)) void RF_ClrMsg(RFMSG_STRUCT *msg)
{
    memset(msg, 0x00, sizeof(RFMSG_STRUCT));
}


/**
 * Function to calculate the checksum of buffer of x bytes
 */
__attribute__((mips16)) uint8_t RF_CksCalc(RFMSG_STRUCT *msg)
{
    uint8_t i;
    uint8_t *buffPt;
    uint16_t cks=0;

    buffPt = msg;

    for (i=0; i<msg->len-2; i++)
    {
        cks += *(buffPt+i);
    }
    cks += msg->ttl;

    cks = (uint8_t)(cks & 0x00FF);

    return cks;
}


/******************************************************************************/
/* PWM Functions                                                              */
/******************************************************************************/

/**
 * Function to config the dimming
 * @param 1 - SYS_STRUCT pointer
 */
__attribute__((mips16)) void PWM_ConfigDimming(SYS_STRUCT *sysData)
{
    if (sysData->dutyTmp > PWM_MAX)
        sysData->dutyTmp = PWM_MAX;

    if (sysData->dutyTmp < PWM_MIN)
        sysData->dutyTmp = PWM_MIN;

    /* Initialise duty variable control */
    sysData->duty = 0;

    /* Set the interval for changing duty-cycle */
    sysData->dimInt = 1;
    
    /* Set order to do dimming */
    sysData->flagDim = 1;

    /* Config timer 5 for the dimming - The dimming function will enable the timer */
    OpenTimer5(T5_OFF | T5_SOURCE_INT | T5_PS_1_32, PR_TIMER_DIM(sysData->duty));
    ConfigIntTimer5(T5_INT_ON | T5_INT_PRIOR_3 | T5_INT_SUB_PRIOR_0);
}


/**
 * Function to set the dimming/duty
 * @param 1 - SYS_STRUCT pointer
 */
__attribute__((mips16)) void PWM_Dimming(SYS_STRUCT *sysData)
{

    if (sysData->dutyTmp > PWM_MAX)
        sysData->dutyTmp = PWM_MAX;

    if (sysData->dutyTmp < PWM_MIN)
        sysData->dutyTmp = PWM_MIN;

    if (sysData->dutyTmp != sysData->duty)
    {
        /* Enable Timer 5 */
        OpenTimer5(T5_ON |  T5_SOURCE_INT | T5_PS_1_32, PR_TIMER_DIM(sysData->duty));
        //T5CONSET = 0x8000;
    }
}


/**
 * Function to save the current dimming/duty
 * @param 1 - SYS_STRUCT pointer
 */
__attribute__((mips16)) void PWM_SaveAuxDimming(SYS_STRUCT *sysData)
{
    uint8_t *buffPt;

    sysData->dutyAux = sysData->dutyTmp;

    buffPt = &sysData->dutyAux;
    RTC_MCP7952x_WrtEEPROM_Array(DUTY_AUX_ADD, buffPt, UINT16_SIZE);
}


/******************************************************************************/
/* RTC_EEPROM Functions                                                       */
/******************************************************************************/

/* RTC_EEPROM Functions */

/**
 * Function to load the system with the saved data
 * @param 1 - SYS_STRUCT pointer
 * @param 2 - MEMS_STRUCT pointer
 * @param 3 - PROF_STRUCT pointer
 * @param 4 - ALARM_STRUCT pointer
 * @param 5 - MAX_I_CAL_STRUCT pointer
 * @param 6 - PWR_CONSUME_STRUCT pointer
 * @param 7 - RTC_DATA pointer
 */
__attribute__((mips16)) void RTC_MCP7952x_GetSavedData(SYS_STRUCT *sysData, MEMS_STRUCT *memsData, PROF_STRUCT *profData, ASTRO_STRUCT *astroData, ALARM_STRUCT *alrData,\
                                                       PWR_LF_CAL_STRUCT *pwrLFcalData, PWR_CONSUME_STRUCT *pwrData, RF_STRUCT *rfData)
{
    uint8_t *buffPt;
    
    /* Reading network configs - First position of memory */
    buffPt = &sysData->net;
    RTC_MCP7952x_ReadEEPROM_Array(START_STRUCT_ADD, buffPt, NW_SIZE);

#if DEBUG_CHECK_DEBUGCTRL
    /* Check if the board was programmed, if yes turn off the debug messages and save it */
    if ((sysData->sn == 0xFFFF) || (sysData->net == 0xFFFF))
        sysData->debugCtrl = SYS_ON;
    else
        sysData->debugCtrl = SYS_OFF;

    RTC_MCP7952x_WrtEEPROM_Byte(DEBUG_ADD, sysData->debugCtrl);
 #endif

    /* Reading the rest of the saved data */
    buffPt = &sysData->sysStt;
    RTC_MCP7952x_ReadEEPROM_Array(SYS_STT_ADD, buffPt, REST_DATA_SIZE);

    /* Review data read */
    if (sysData->sysStt > SYS_SOS)
        sysData->sysStt = SYS_ON;

    /* Initialise system state control */
    sysData->sysSttAnt = sysData->sysStt;

    if (sysData->profileStt > DIM_PROF_ASTO_ON)
        sysData->profileStt = DIM_MANUAL;

    if (sysData->ldrCtrl > LDR_SP)
        sysData->ldrCtrl = LDR_OFF;

    if (sysData->ttlMAX == 0xFF)
        sysData->ttlMAX = TTL_DEFAULT;

    /* Reading work-hours */
    buffPt = &sysData->workHours;
    RTC_MCP7952x_ReadEEPROM_Array(WH_ADD, buffPt, UINT32_SIZE);

    /* Reading duty value */
    buffPt = &sysData->dtSttMch;
    RTC_MCP7952x_ReadEEPROM_Array(DUTY_TMP_ADD, buffPt, UINT16_SIZE);

    /* Reading duty factor */
    buffPt = &sysData->dutyFact;
    RTC_MCP7952x_ReadEEPROM_Array(DUTY_FACT_ADD, buffPt, DOUBLE_SIZE);

    if ((sysData->dutyFact > 1.0) || (sysData->dutyFact < 0.1))
        sysData->dutyFact = 1.0;    
    
    /* Reading PIR information */
    buffPt = &sysData->pirCtrl;
    RTC_MCP7952x_ReadEEPROM_Array(PIR_ADD, buffPt, PIR_DATA_SIZE);

    /* Check if at power-off the luminary is with PIR_ON */
    if ((sysData->pirCnt > 0) && (sysData->pirCnt < PIR_TIMEOUT))
    {
        /* Get the Duty saved from PIR detection if duty > MAX */
        sysData->dtSttMch = sysData->dutyPIR;        
    }
    
    /* Reset all values for PIR handling */
    sysData->pirCtrl = PIR_OFF;
    sysData->pirCnt = 0;
    sysData->dutyPIR = 0;

    /* Set a correct duty value */
    if (sysData->dtSttMch > PWM_MAX)
        sysData->dtSttMch = PWM_MAX;

    /* Get the configured RF frequency */
    rfData->freq = RTC_MCP7952x_ReadEEPROM_Byte(RF_FREQ_ADD);
    
    if ((rfData->freq > RF_918) || (rfData->freq < RF_868))
    {
        rfData->freq = RF_868;
        RTC_MCP7952x_WrtEEPROM_Byte(RF_FREQ_ADD, rfData->freq);
    }
    
    /* Reading the profiles data */
    buffPt = profData;
    RTC_MCP7952x_ReadEEPROM_Array(PROF_ADD, buffPt, PROF_SIZE);

    /* Set order to update profiles data and check the profile */
    sysData->updateID = PROF_UPDATE;

    /* Get the Addon configs */
    buffPt = &sysData->pirENABLE;
    RTC_MCP7952x_ReadEEPROM_Array(PIR_ENABLE_ADD, buffPt, ADDON_CONF_DATA_SIZE);

    /* Movement sensor */
    if (sysData->pirENABLE > PIR_ENABLE)
        sysData->pirENABLE = PIR_DISABLE;

    /* Debug messages */
    if (sysData->debugCtrl > SYS_ON)
        sysData->debugCtrl = SYS_ON;

    /* Lamp Temperature sensor */
    if (sysData->tLedENABLE > SYS_ON)
        sysData->tLedENABLE = SYS_OFF;
   
    /* Encryption */
    if (sysData->encCtrl > ENC_ON)
        sysData->encCtrl = ENC_OFF;

    /* Get the power-supply frequency - 50000 or 60000 mHz */
    sysData->pwrFreq = RTC_MCP7952x_ReadEEPROM_Byte(PWR_FREQ_ADD);

    /* If the value is not defined set the default - 50z */
    if ((sysData->pwrFreq != PWR_FREQ_50Hz) && (sysData->pwrFreq != PWR_FREQ_60Hz))
        sysData->pwrFreq = PWR_FREQ_50Hz;

    /* Get the Astronomical Clock configs */
    buffPt = &astroData->hhSset;
    RTC_MCP7952x_ReadEEPROM_Array(ASTRO_CLK_ADD, buffPt, ASTRO_CLK_DATA_SIZE);

    if ((astroData->dimStt == 0xFF) || (astroData->dimSttAnt == 0xFF))
    {
        astroData->dimCurr = PWM_ASTROCLK_DEFAULT;       /* This dimming will be used when there is no dimming configured during the sunset */
        astroData->dimStt = SYS_ON;
        astroData->dimSttAnt = SYS_ON;
    }
    else if ((sysData->profileStt == DIM_PROF_ON) || (sysData->profileStt == DIM_MANUAL))
    {
        /* Force this flag to process the profiles */
        astroData->dimStt = SYS_ON;
        astroData->dimSttAnt = SYS_ON;
    }
    
    // Read Volume Consumption Data
    volume = 0.0;
    i1 = 0.0;
        
    buffPt = &pwrData->kwhSum;
    RTC_MCP7952x_ReadEEPROM_Array(POWER_CALC_ADD, buffPt, POWER_CALC_DATA_SIZE);
    
    volume = (float)pwrData->kwhSum;
    i2 = volume;
    
    // Read Calibration Constants
    buffPt = &quadratic_AN1;
    RTC_MCP7952x_ReadEEPROM_Array(AN1_QUADRATIC_ADD, buffPt, AN_QUADRATIC_DATA_SIZE);
    if (quadratic_AN1 < -1000000.0 || quadratic_AN1 > 1000000.0) quadratic_AN1 = 1.0;
    
    buffPt = &slope_AN1;
    RTC_MCP7952x_ReadEEPROM_Array(AN1_SLOPE_ADD, buffPt, AN_SLOPE_DATA_SIZE);
    if (slope_AN1 < -1000000.0 || slope_AN1 > 1000000.0) slope_AN1 = 1.0;
    
    buffPt = &intercept_AN1;
    RTC_MCP7952x_ReadEEPROM_Array(AN1_INTERCEPT_ADD, buffPt, AN_INTERCEPT_DATA_SIZE); 
    if (intercept_AN1 < -1000000.0 || intercept_AN1 > 1000000.0) intercept_AN1 = 0.0;
    
    // Set the interval for the power consumption calculation
    pwrData->intrSec = HALF_MINUTE;
    pwrData->intrF = HALF_MINUTE_INT;
    pwrData->intr2hs = (ONE_HOUR) / (pwrData->intrSec);

    // Check the values read
    if (pwrData->flagInit == 0xFF)
    {
        volume = 0.0;
        pwrData->flagInit = 1;
    }

    /* Reading the alarm configurations */
    /* TODO <Implement the reading of alarm configurations> */
}


/**
 * Function to compensate the RTCC using calibration register, relation between temperature and frenquency clock
 * @param 1 - SYS_STRUCT pointer
 * @param 2 - Current Hours
 */
__attribute__((mips16)) void RTC_MCP7952x_TempComp(SYS_STRUCT *sysData, uint8_t hours)
{
    uint8_t sgntemp;
    int8_t temp;
    uint16_t dT;

    /* This function obtains 4 main values : the pcb temperature (and the sign), the difference |dT|=|temp-temp0|
     * and the calibration value (compensation)(minus sign)
     * |dT| will help to compensate the temp drift, through the calibration register */

    temp = sysData->tempPCB;

    /* Check if tempPCB is positive */
    if((temp & 0x8000) == 0x0000)    
    {
        sgntemp = 0x00;
    }
    else
    {
        sgntemp = 0x01;              	/* if temp is negative do 2's complement of the tempPCB value */
        temp = (~temp)+1 ;
    }

    /* Calculate the differential between T0 and the ambient temperature */
    if(!sgntemp)
    {                                   // if a positive temperature
        if(temp >= TEMP0)               // and temp higher than turnover point
            dT = temp - TEMP0;          // build the temp difference
        else
            dT = TEMP0 - temp;          // if temp lower than turnover point, build |temp-temp0|
    }
    else
    {
        dT = TEMP0 + temp;              // if a negative temperature, dT = temp0+temp
    }


    /* once dT is calculated, the final formula is: */
    sysData->calib = (TC*(dT*dT))/1000;          //  unsigned char calibration value

    if(((TC*(dT*dT))%1000)>=500)
        sysData->calib++;                        //  rounding instead truncation

    //  write in the calibration(sgn='-') register the compensation value = -(TC/1000)*dT^2(increase freq)
    RTC_MCP7952x_SetCalib(sysData->calib, hours, SGN_NEGATIVE);

}



/******************************************************************************/
/* System Functions                                                           */
/******************************************************************************/

/**
 * Function to handle with system updates - clock, profiles or configs
 * @param 1 - SYS_STRUCT pointer
 * @param 2 - RTC_DATA pointer
 * @param 3 - PROF_STRUCT pointer
 * @param 4 - ASTRO_STRUCT pointer
 * @param 5 - MEMS_STRUCT pointer
 * @param 6 - ALARM_STRUCT pointer
 * @param 7 - PWR_LF_CAL_STRUCT pointer
 * @param 8 - PWR_CONSUME_STRUCT pointer
 */
__attribute__((mips16)) void SYS_Update(SYS_STRUCT *sysData, RTC_DATA *rtcData, PROF_STRUCT *profData, ASTRO_STRUCT *astroData,\
                                         MEMS_STRUCT *memsData, ALARM_STRUCT *alrData, PWR_LF_CAL_STRUCT *pwrLFcalData)
{
    uint8_t *buffPt;

    switch(sysData->updateID)
    {
        case RTC_UPDATE:

            /* Write the new calendar to RTC */
            RTC_MCP7952x_WrtCalendar(rtcData);

            #if DEBUG_RTC_UPDATE
                UART_PrintString("\nRTC updated!\n");
            #endif

            break;

        case PROF_UPDATE:

            //Recalculating the absolute minutes for the profiles
            profData->minAbsPbeg[0] = profData->hhBeg1*60 + profData->mmBeg1;
            profData->minAbsPend[0] = profData->hhEnd1*60 + profData->mmEnd1;

            profData->minAbsPbeg[1] = profData->hhBeg2*60 + profData->mmBeg2;
            profData->minAbsPend[1] = profData->hhEnd2*60 + profData->mmEnd2;

            profData->minAbsPbeg[2] = profData->hhBeg3*60 + profData->mmBeg3;
            profData->minAbsPend[2] = profData->hhEnd3*60 + profData->mmEnd3;

            profData->minAbsPbeg[3] = profData->hhBeg4*60 + profData->mmBeg4;
            profData->minAbsPend[3] = profData->hhEnd4*60 + profData->mmEnd4;

            /* Update the profiles configurations to eeprom */
            buffPt = profPt;
            RTC_MCP7952x_WrtEEPROM_Array(PROF_ADD, buffPt, PROF_SIZE);

            /* Set the flag of 60s for the system check if it is inside a profile */
            sysData->flagChkProf = 1;

            #if DEBUG_PROF_UPDATE
                UART_PrintString("\nProfiles updated!\n");
            #endif

            break;

        case ASTRO_UPDATE:

            astroData->minAbsSset = astroData->hhSset*60 + astroData->mmSset;
            astroData->minAbsSrise = astroData->hhSrise*60 + astroData->mmSrise;

            /* Update the astronomical clock configurations to eeprom */
            buffPt = &astroData->hhSset;
            RTC_MCP7952x_WrtEEPROM_Array(ASTRO_CLK_ADD, buffPt, ASTROCLK_DATA_LEN);

            break;

        case CONFIGS_UPDATE:

            /* Update the configurations system to the EEPROM*/
            buffPt = &sysData->sysStt;
            RTC_MCP7952x_WrtEEPROM_Array(SYS_STT_ADD, buffPt, CONF_SIZE);

            #if DEBUG_GCONF_UPDATE
                UART_PrintString("\nGen. Configs. updated!\n");
            #endif

            break;

        // Update maximum current value and correct values for the MEMS device
        case UPDATE_SYS_CONFIG:

#ifdef MEMS_DEVICE
            /* Get the initial position for the MEMS Device - Stability Sensor */
            MEMS_LIS331DL_InitReadOutXYZ(memsData);

            /* Update the configurations system to the EEPROM*/
            buffPt = memsData;
            RTC_MCP7952x_WrtEEPROM_Array(MEMS_ADD, buffPt, MEMS_DATA_SIZE);

            alrData->stability.init = ALR_STAB_CONFIG;
#endif

#ifdef POWER_METER
            /* Calibrate the maximum current using values of power consumption at x value of dimming
             * By default the system supposes that the LED are connected to the board
             */

            if (pwrLFcalData->set == PWR_LF_CAL_OFF)
            {
                SYS_PwrLFset(sysData, pwrLFcalData);
            }

#endif

            break;

        case ADDON_CONFIGS_UPDATE:

            /* Update the configurations system to the EEPROM*/
            buffPt = &sysData->pirENABLE;
            RTC_MCP7952x_WrtEEPROM_Array(PIR_ENABLE_ADD, buffPt, ADDON_CONF_DATA_SIZE);

            buffPt = &sysData->dutyFact;
            RTC_MCP7952x_WrtEEPROM_Array(DUTY_FACT_ADD, buffPt, DOUBLE_SIZE);
            
            break;

        case PWR_FREQ_UPDATE:

            /* Get the power-supply frequency - 50000 or 60000 mHz */
            RTC_MCP7952x_WrtEEPROM_Byte(PWR_FREQ_ADD, sysData->pwrFreq);

            break;
                       
        case ENCRYPTION_UPDATE:
            
            /* Read from the EEPROM the value saved when the RF message was received */
            sysData->encCtrl = RTC_MCP7952x_ReadEEPROM_Byte(ENC_ADD);
            
            break;
            
        case CONFIG_SENSORS_UPDATE:
            
            buffPt = &quadratic_AN1;
            RTC_MCP7952x_WrtEEPROM_Array(AN1_QUADRATIC_ADD, buffPt, 4);
                                
            buffPt = &slope_AN1;
            RTC_MCP7952x_WrtEEPROM_Array(AN1_SLOPE_ADD, buffPt, 4);
                                
            buffPt = &intercept_AN1;
            RTC_MCP7952x_WrtEEPROM_Array(AN1_INTERCEPT_ADD, buffPt, 4);
            
            break;
            
        default:
            break;
    
    }

    /* Clear the update flag*/
    sysData->updateID = NO_UPDATE;
    
    //TEST
    
}


/**
 * Function to get the mean values from the ADC and normalise those values
 * @param 1 - SYS_STRUCT pointer
 * @param 2 - ADC_STRUCT pointer
 */

__attribute__((mips16)) void SYS_MeanADCcalc(SYS_STRUCT *sysData, ADC_STRUCT *adcData)
{
    float a,b,qmax,i_in,ad4,ad20;
    uint8_t j,i;
    uint16_t mean[ADC_N_CH];    
 
    //qmax =650.0;
    //ad4 = 185.0;  //
    //ad20 = 935.0; //930
    //a = qmax/(ad20-ad4);
    //b = -qmax*ad4/(ad20-ad4);
    //flowAct = (float)analog_1*a + b;
    
    /* Set all values of the array to 0 */
    memset(mean, 0x00, sizeof(mean));

    for (j=0; j<ADC_N_CH; j++)
    {
        for (i=0; i<ADC_N_SAMPLES; i++)
        {
             mean[j] += adcData->samples[j][i];
        }

        mean[j] /= ADC_N_SAMPLES;
    }
    
    analog_1 = mean[0];
    analog_2 = mean[1];
    analog_3 = mean[2];
    analog_4 = mean[3];   
    
    flowAct = (float)analog_1*slope_AN1 + intercept_AN1;
    if(flowAct < 0.0) flowAct = 0.0;    
}


/**
 * Function to normalise DC Voltage (7V) value
 * @param 1 - SYS_STRUCT pointer
 * @param 2 - mean value corresponding to the voltage
 */
__attribute__((mips16)) void SYS_VoltDCCalc(SYS_STRUCT *sysData, uint16_t val)
{
    /* Use a function to set the value to Volts or leave it in 0-1024, ADC direct value */
    sysData->voltDC = val;
}


/**
 * Function to normalise LDR value - convert from ADC (0-1024) to voltage
 * @param 1 - SYS_STRUCT pointer
 * @param 2 - mean value corresponding to Lux from the LDR sensor
 */
__attribute__((mips16)) void SYS_LDRcalc(SYS_STRUCT *sysData, uint16_t val)
{
    double ldrInVoltage, ldrCurrent;
    
    sysData->ldrMean.buff[sysData->ldrMean.ind] = val;

    if (sysData->ldrMean.ind < N_MEAN)
        sysData->ldrMean.ind++;
    else
        sysData->ldrMean.ind = 0;
    
    /* Get mean value from ADC */
    ldrInVoltage = (double)(mediana9(sysData->ldrMean.buff));
    
#ifdef _NEMA_    
    
    sysData->ldr = (uint16_t)((ldrInVoltage * 2.9278) * 2.1364);  //RL = 2.2k
        
#else   
    
    /* Start calculations to convert ADC value to Lux */
    ldrInVoltage = (ldrInVoltage * 3.3) / 1023.0;   
    
    /* AMS302 Sensor curve - Voltage to Lux */
    ldrCurrent = 0.005 * ldrInVoltage - 0,00007;
    ldrCurrent = ldrCurrent * 1000000.0;
   
    sysData->ldr = (uint16_t)((ldrCurrent - 0.3) / 2.597);    
    
#endif       
}


/**
 * Function to normalise Temperature value - convert from ADC (0-1024) to voltage
 * @param 1 - SYS_STRUCT pointer
 * @param 2 - mean value corresponding to the temperature from the sensor
 */
__attribute__((mips16)) void SYS_MCP9700Acalc(SYS_STRUCT *sysData, uint16_t val)
{
    /* TODO <Colocar limite correspondente a -128º e a 127º> */

    sysData->tempPCB = (int8_t)(0.332701*val - 56.605916) - SYS_TPCB_OFFSET;
}


/**
 * Function to implement system state-machine
 * @param 1 - SYS_STRUCT pointer
 * @param 2 - PROF_STRUCT pointer
 * @param 3 - RTC_DATA pointer
 * @param 4 - ALARM_STRUCT pointer
 */
__attribute__((mips16)) void SYS_SttMachine(SYS_STRUCT *sysData, PROF_STRUCT *profData, ASTRO_STRUCT *astroData, RTC_DATA *rtcData, ALARM_STRUCT *alrData,\
                                            RF_STRUCT *rfData, PWR_LF_CAL_STRUCT *pwrLFcalData, PWR_CONSUME_STRUCT *pwrData, DALI_STRUCT *daliData)
{
    uint8_t *buffPt;
    uint16_t dimChg = sysData->dtSttMch;

    /* If a Max Current Calibration is in Progress suspend the State-Machine processing */
    if (pwrLFcalData->set == PWR_LF_CAL_OFF)
    {
        switch(sysData->sysStt)
        {
            case SYS_ON:

                /* Check if there was a change of state */
                if ((sysData->sysSttAnt == SYS_OFF) || (sysData->sysSttAnt == SYS_SOS))
                {
                    sysData->sysSttAnt = SYS_ON;

                    /* Get the old duty and do the dimming */
                    sysData->dtSttMch = sysData->dutyAux;
                    sysData->dutyTmp = sysData->dtSttMch-10;        /* Force the dimming even in alarm state */

                    sysData->flagDim = 1;

                    #if DEBUG_SYS_STT
                        UART_PrintString("\nSys ON\n");
                    #endif
                }


                /* Check if there is a PIR detection - If local PIR Detection is Enable */
                if (sysData->pirENABLE > PIR_DISABLE)
                {
                    if (sysData->pirENABLE == PIR_PIN_ON)
                    {
                        delayUs(10);        // avoids signal bouncing

                        if ((sysData->pirENABLE == PIR_PIN_ON) && (sysData->pirCtrl == PIR_OFF))
                        {
                            sysData->pirCtrl = PIR_ON;
                            sysData->pirSendCnt = 1;                    /* Start counting to Re-Send the PIR msg */
                            rfData->msgIDsend = PIR_CONTROL_SEND;       /* set order to send PIR message */
                            
                        }
                    }
                    else
                    {
                        delayUs(10);        // avoids signal bouncing
                        
                        if ((sysData->pirENABLE == PIR_PIN_OFF) && (sysData->pirCtrl == PIR_ON))
                        {
                            sysData->pirCtrl = PIR_OFF;
                            sysData->pirSendCnt = 1;                    /* Start counting to Re-Send the PIR msg */                            
                            rfData->msgIDsend = PIR_CONTROL_SEND;       /* set order to send PIR message */
                        }
                    }

                } //END if (sysData->pirENABLE > PIR_DISABLE)


                /* Only check the profiles and LDR when the PIR is OFF */
                if (sysData->pirCtrl == PIR_OFF)
                {
                    /* Check if there was a change to PIR_OFF*/
                    if (sysData->pirCnt > 0)
                    {
                        /* Set and save the PIR data */
                        sysData->pirCnt = 0;
                        sysData->dtSttMch = sysData->dutyPIR;
                        sysData->dutyPIR = 0;

                        buffPt = &sysData->pirCtrl;
                        RTC_MCP7952x_WrtEEPROM_Array(PIR_ADD, buffPt, PIR_DATA_SIZE);

                        /* Set the order to do dimming*/
                        sysData->flagDim = 1;
                    }                    
                    
                    /* If the Astronomical clock is ON it is going to control the Dimming ON/OFF */
                    if (astroData->dimStt == SYS_ON)
                    {

                        /* Check if the State has changed from OFF to ON */
                        if ((sysData->profileStt == DIM_ASTROCLK_ON) || (sysData->profileStt == DIM_PROF_ASTO_ON))
                            SYS_AstroClk_DimChg(astroData, sysData, SYS_ON);

                        /* Profiles ON and inside a profile */
                        if ((sysData->profileStt == DIM_PROF_ON) || (sysData->profileStt == DIM_PROF_ASTO_ON))
                        {
                            /* Check if it's inside the profiles and update RTC data */
                            if (sysData->flagChkProf == 1)
                            {
                                /* Check the timestamp of the profiles */
                                SYS_ProfCheck(profData, rtcData);

                                /* Set the respective dimming */
                                switch(profData->profFlag)
                                {
                                    case PROF_1:
                                        dimChg = PERCENT_TO_DUTY(profData->dim1);
                                        break;

                                    case PROF_2:
                                        dimChg = PERCENT_TO_DUTY(profData->dim2);
                                        break;

                                    case PROF_3:
                                        dimChg = PERCENT_TO_DUTY(profData->dim3);
                                        break;

                                    case PROF_4:
                                        dimChg = PERCENT_TO_DUTY(profData->dim4);
                                        break;

                                    default:
                                        break;
                                }

                                /* Check if the dimming has been changed */
                                if (dimChg != sysData->dtSttMch)
                                {
                                    sysData->dtSttMch = dimChg;

                                    /* Save the new profile dimming */
                                    buffPt = &sysData->dtSttMch;
                                    RTC_MCP7952x_WrtEEPROM_Array(DUTY_TMP_ADD, buffPt, UINT16_SIZE);

                                    /* Set the order to do dimming */
                                    sysData->flagDim = 1;
                                }

                                /* Reset the flag for profile check */
                                sysData->flagChkProf = 0;

                            } // END if (sysData->flagChkProf == 1)

                        } // END if ((sysData->profileStt == DIM_PROF_ON) || (sysData->profileStt == DIM_PROF_ASTO_ON))


                        /* Check if LDR control is ON or profiles ON and outside the profiles */
                        /* The LDR control is made at the "flag1min" */


                    } // END if (astroData->dimStt == ON)
                    else if (astroData->dimStt == SYS_OFF)
                    {
                        /* Check if the State has changed from OFF to ON */
                        if ((sysData->profileStt == DIM_ASTROCLK_ON) || (sysData->profileStt == DIM_PROF_ASTO_ON))
                        {
                            SYS_AstroClk_DimChg(astroData, sysData, SYS_OFF);
                        }
                        else
                        {
                            /* Correct the state once there is no Astro clock defined */
                            astroData->dimStt = SYS_ON;
                        }

                    } // END if (astroData->dimStt == ON)

                }
                else if (sysData->pirCtrl == PIR_ON)
                {
                    /* PIR Control is ON */

                    /* Check if there was a change to PIR_ON */
                    if (sysData->pirCnt == 0)
                    {
                        /* Start the PIR counter - this counter will be incremented in the 1s interrupt routine */
                        sysData->pirCnt = 1;

                        /* save the current duty and set the duty to PIR_DUTY */
                        sysData->dutyPIR = sysData->dutyTmp;
                        sysData->dtSttMch = PIR_DUTY;

                        buffPt = &sysData->pirCtrl;
                        RTC_MCP7952x_WrtEEPROM_Array(PIR_ADD, buffPt, PIR_DATA_SIZE);

                        /* Set the order to do dimming */
                        sysData->flagDim = 1;
                    }
                    else if (sysData->pirCnt > PIR_TIMEOUT)
                    {
                        /* After timeout PIR goes OFF and duty goes to the normal value */
                        sysData->pirCtrl = PIR_OFF;

                        /* Reset the counting variable */
                        sysData->pirCnt = 0;
                    }

                } // END if (sysData->pirCtrl == OFF)

                break;

            case SYS_OFF:

                if (sysData->sysSttAnt > SYS_OFF)
                {
                    sysData->sysSttAnt = SYS_OFF;

                    /* save the current duty */
                    PWM_SaveAuxDimming(sysData);

                    #if DEBUG_SYS_STT
                        UART_PrintString("\nSys OFF\n");
                    #endif
                }

                /* Set Duty to 0% - The duty before sys off should have been saved */
                if (sysData->dtSttMch > 0)
                {
                    sysData->dtSttMch = 0;
                    sysData->flagDim = 1;
                }

                break;

            case SYS_SOS:

                if (sysData->sysSttAnt != SYS_SOS)
                {
                    sysData->sysSttAnt = SYS_SOS;

                    /* Save the current dimming */
                    PWM_SaveAuxDimming(sysData);

                    #if DEBUG_SYS_STT
                        UART_PrintString("\nSys SOS\n");
                    #endif
                }

                /* Set the duty to Maximum */
                if (sysData->dtSttMch < PWM_WITH_DTFACT(PWM_MAX))
                {
                    sysData->dtSttMch = PWM_WITH_DTFACT(PWM_MAX);
                    sysData->flagDim = 1;
                }

                break;

            default:
                break;

        } // END switch(sysData->sysStt)

    //END if (currMAXcalData->set == MAX_I_CAL_OFF)
    }
    else if (pwrLFcalData->set > PWR_LF_CAL_OFF)
    {
        /* If a Power Lamp Fail Calibration was set
         *  -> Wait for the real dimming reach 20%
         *  -> measure the current and save the value
         */
         SYS_PwrLFcal(sysData, pwrLFcalData, pwrData);

    }


    /* Check if there is any order to do dimming
     * The duty should have been saved to the EEPROM */
    if (sysData->flagDim == 1)
    {

        /* Check if the system is in temperature alarm mode */
        if ((alrData->tempPCB.set == SYS_ON) && (sysData->sysStt == SYS_ON) && (pwrLFcalData->set == PWR_LF_CAL_OFF))
        {
            /* if there is a changing on the duty
             * and the temperature alarm is set, update the variables */

            /* if the new duty is lower than duty saved when alarm was detected update the current duty */
            if (sysData->dtSttMch < sysData->dutyTmp)
                sysData->dutyTmp = sysData->dtSttMch;

            /* Update new duty to the alarm duty saved */
            alrData->dutyAlarm = sysData->dtSttMch;
        }
        else
        {
            sysData->dutyTmp = sysData->dtSttMch;

        } // END if (alrData->tempPCB.set == ON)

        PWM_Dimming(sysData);

        /* Set order to send DALI dimming message */
        daliData->tm2sndFlag = DALI_TIME2SEND+1;

        /* Reset dimming flag */
        sysData->flagDim = 0;
    }
}


/**
 * Function to search if the system should be inside of a profile
 * @param 1 - PROF_STRUCT pointer
 * @param 2 - RTC_DATA pointer
 * @return  - Flag that indicates a profile change
 */
__attribute__((mips16)) uint8_t SYS_ProfCheck(PROF_STRUCT *profData, RTC_DATA *rtcData)
{
    uint8_t i;
    uint8_t profChange=0, profEmpty=0, profInside=0;

    for (i=0; i<N_PROFILES; i++)
    {
        if (profData->minAbsPend[i] < MINUTES_24H)
        {
            /* Check if the profile goes from one day to the other - ex: 22h to 4h */
            if (profData->minAbsPbeg[i] < profData->minAbsPend[i])
            {
                if ((rtcData->minAbs >= profData->minAbsPbeg[i]) && (rtcData->minAbs < profData->minAbsPend[i]))
                {
                    /* Valid Profile */
                    profInside = 1;

                    /* Set the profile flag */
                    if (profData->profFlag != (i+1))
                    {
                        profData->profFlag = i+1;
                        profChange = PROFILE_CHANGE;
                    }

                    break;
                }
            }
            else if (profData->minAbsPbeg[i] > profData->minAbsPend[i])
            {
                if ((rtcData->minAbs >= profData->minAbsPbeg[i]) || (rtcData->minAbs < profData->minAbsPend[i]))
                {
                    /* Valid Profile */
                    profInside = 1;

                    /* Set the profile flag */
                    if (profData->profFlag != (i+1))
                    {
                        profData->profFlag = i+1;
                        profChange = PROFILE_CHANGE;
                    }

                    break;
                }
            }
            else if ((profData->minAbsPbeg[i] == profData->minAbsPend[i]))
            {
                /* Profile not valid */
                profEmpty = 1;
            }

        }
        else
        {
            /* Not valid profile */
            profEmpty = 1;
        }
    }

    /* If not in a Profile and have detected a not valid Profile, force the flag to NO_PROFILES */
    if ((profEmpty == 1) && (profInside == 0))
        profData->profFlag = NO_PROFILES;


    return profChange;
}


/**
 * Function to check if there is any alarm situation
 * @param 1 - SYS_STRUCT pointer
 * @param 2 - MEMS_STRUCT pointer
 * @param 3 - ALARM_STRUCT pointer
 * @param 4 - RF_STRUCT pointer
 * @param 5 - PWR_LF_CAL_STRUCT pointer
 * @param 6 - PWR_CONSUME_STRUCT pointer
 */
__attribute__((mips16)) void SYS_CheckAlarm(SYS_STRUCT *sysData, MEMS_STRUCT *memsData, ALARM_STRUCT *alrData, RF_STRUCT *rfData,\
                                            PWR_LF_CAL_STRUCT *pwrLFcalData, PWR_CONSUME_STRUCT *pwrData)
{
    int16_t alrError;

    /* Check for PCB temperature alarm */
    if ((sysData->tempPCB > alrData->tempPCB.maxVal) && (alrData->tempPCB.set == SYS_OFF))
    {
        /* Set alarm-state ON*/
        alrData->tempPCB.set = SYS_ON;
        
        /* Set the resume flag for the respective alarm */
        alrData->resume |= (alrData->tempPCB.set << TEMPPCB_POS);
    }

    /* Do the duty adjust using the difference between current PCB temperature and max value */
    if (alrData->tempPCB.set == SYS_ON)
    {
        alrError = (sysData->tempPCB - alrData->tempPCB.maxVal) * 10;

        /* If is the 1st time save the current duty */
        if (alrData->tempPCB.time == 0)
        {
            /* save the current duty value */
            alrData->dutyAlarm = sysData->dutyTmp;
        }

        /* Change the duty in the alarm mode each minute - using the "alrError" */
        if (alrData->tempPCB.time > ALR_TPCB_TIME)
        {        
            if ((sysData->tempPCB < alrData->tempPCB.maxVal) && (sysData->dutyTmp >= alrData->dutyAlarm))
            {
                /* Set alarm-state OFF and reset the alarm time */
                alrData->tempPCB.set = SYS_OFF;
                alrData->tempPCB.time = 0;

                /* Set the resume flag for the respective alarm */
                alrData->resume &= (alrData->tempPCB.set << TEMPPCB_POS);
                
                /* Correct the dimming */ 
                sysData->dutyTmp = alrData->dutyAlarm;

                /* Clear the duty saved */
                alrData->dutyAlarm = 0;
            }
            else
            {
                /* Adjust the duty */
                sysData->dutyTmp -= alrError;
            }
            
            /* Set the order to do dimming */
            sysData->flagDim = 1;

            /* Reset the control flag */
            alrData->tempPCB.time = 1;
        }

        /* Increment the time control for the alarm */
        alrData->tempPCB.time++;

    } // END if (alrData->tempPCB.set == ON)

#ifdef MEMS_DEVICE
    /* Do the Stability control if the initial coordenates are configured */
    if (alrData->stability.init == ALR_STAB_CONFIG)
    {
        /* Check for Stability alarm */
        if ((abs(memsData->xx - memsData->xxInit) > alrData->stability.limit) || \
             (abs(memsData->yy - memsData->yyInit) > alrData->stability.limit) || \
             (abs(memsData->zz - memsData->zzInit) > alrData->stability.limit))
        {
            if (alrData->stability.time > ALR_STAB_INT)
            {
                alrData->stability.set = SYS_ON;

                /* Set the resume flag for the stability alarm */
                alrData->resume |= (alrData->stability.set << STAB_POS);
            }
            else
            {
                alrData->stability.time++;
            }

            #if DEBUG_STAB_ALR
                UART_PrintString("\nStability Alarm detected!\n");
            #endif
        }
        else if (alrData->stability.time > 0)
        {
            alrData->stability.time = 0;

            alrData->stability.set = SYS_OFF;

            /* Set the resume flag for the stability alarm */
            alrData->resume &= (alrData->stability.set << STAB_POS);

        }// END if (stability > Threshold)
    
    } //END if (alrData->stability.init == ALR_STAB_CONFIG)
#endif

#ifdef POWER_METER

    // Check for the alarm lamp
    if (checkLampAlarm(sysData, pwrLFcalData, pwrData) == 1)
    {
        if (alrData->lamp.time > ALR_L_TIME)
        {
            alrData->lamp.set = SYS_ON;

            // Set the resume flag for the lamp alarm
            alrData->resume |= (alrData->lamp.set << LAMP_POS);
        }
        else
        {
            alrData->lamp.time++;
        }
    }
    else if (alrData->lamp.time > 0)
    {
        alrData->lamp.time = 0;

        alrData->lamp.set = SYS_OFF;

        // Set the resume flag for the lamp alarm
        alrData->resume &= (alrData->lamp.set << LAMP_POS);
    }

#endif


    /* Check the DC voltage */
    if ((sysData->volt > ALR_V_MOC_MAX) || (sysData->volt < ALR_V_MOC_MIN))
    {
        if (alrData->voltage.time > ALR_V_TIME)
        {
            alrData->voltage.set = SYS_ON;

            /* Set the resume flag for the lamp alarm */
            alrData->resume |= (alrData->voltage.set << VOLT_POS);
        }
        else
        {
            alrData->voltage.time++;
        }
    }
    else if (alrData->voltage.time > 0)
    {
        alrData->voltage.time = 0;
        alrData->voltage.set = SYS_OFF;

        /* Set the resume flag for the lamp alarm */
        alrData->resume &= (alrData->voltage.set << VOLT_POS);
    }

    /* TODO <Check for others alarms> */


    /* Send a message with the alarms detected between intervals of ALR_INT_SENT - when the alarm stay active */
    if (alrData->resume > NO_ALARMS)
    {
        /* Check if there is a new alarm - the alarm message should be send even if the ALR_INT_SENT interval isn't finished */
        if (alrData->resume != alrData->resumeAnt)
        {
            /* Update the new new alarms */
            alrData->resumeAnt = alrData->resume;
            alrData->sent = 0;
        }

        if (((alrData->sent == 0) || (alrData->sent > ALR_INT_SENT)) && (rfData->msgIDsend == NO_MSG))
        {
            rfData->msgIDsend = ALARM_MSG;

            /* Reset the control flag */
            alrData->sent = 0;
        }

        //Ensures the send of instant alarms
        if (((rfData->msgIDsend == NO_MSG) || (rfData->msgIDsend == ALARM_MSG)) && (alrData->sent < 0xFFFF))
            alrData->sent++;

    }
    else 
    {
        alrData->sent = 0;
        
    }// END if (alrData->resume > NO_ALARMS)

}


/**
 * Function to check if there is a Lamp alarm
 * @param 1 - SYS_STRUCT pointer
 * @param 2 - PWR_LF_CAL_STRUCT pointer
 * @param 3 - PWR_CONSUME_STRUCT pointer
 * @return - 1 for alarm detected 0 for no alarm
 */
__attribute__((mips16)) uint8_t checkLampAlarm(SYS_STRUCT *sysData, PWR_LF_CAL_STRUCT *pwrLFcalData, PWR_CONSUME_STRUCT *pwrData)
{

    /* Below 10% the current consumption is not accurate enough to be analysed */
    if ((sysData->duty >= PWM_WITH_DTFACT(ALR_L_MIN_PWM)) && (sysData->duty < PWM_WITH_DTFACT(PWM_MAX)))
    {
        /* Check if the power is bellow the interval of ALR_L_PERCENT */
        if (pwrData->kw < (pwrLFcalData->valMin * ALR_L_PERCENT_INF))
            return 1;

    }
    else if (sysData->duty == PWM_WITH_DTFACT(PWM_MAX))
    {
        if (pwrData->kw < (pwrLFcalData->valMax * ALR_L_PERCENT_INF))
            return 1;
    }

    return 0;
}


/**
 * Function to start the calibration of the power consumption to detect a lamp failure
 * @param 1 - SYS_STRUCT pointer
 * @param 2 - PWR_LF_CAL_STRUCT pointer
 */
__attribute__((mips16)) void SYS_PwrLFset(SYS_STRUCT *sysData, PWR_LF_CAL_STRUCT *pwrLFcalData)
{
    uint8_t *buffPt;

    pwrLFcalData->set = PWR_LF_CAL_ON;
    pwrLFcalData->actDim = sysData->dtSttMch;

    sysData->dtSttMch = PWM_WITH_DTFACT(PWR_LF_CAL_INITPWM);
    sysData->flagDim = 1;

    // Save the settings to the EEPROM
    buffPt = &pwrLFcalData->set;
    RTC_MCP7952x_WrtEEPROM_Array(PWR_LF_CAL_ADD, buffPt, UINT8_SIZE+UINT16_SIZE);

}


/**
 * Function to calibrate the power consumption to detect a lamp failure
 * @param 1 - SYS_STRUCT pointer
 * @param 2 - PWR_LF_CAL_STRUCT pointer
 * @param 3 - PWR_CONSUME_STRUCT pointer
 */
__attribute__((mips16)) void SYS_PwrLFcal(SYS_STRUCT *sysData, PWR_LF_CAL_STRUCT *pwrLFcalData, PWR_CONSUME_STRUCT *pwrData)
{
    uint8_t *buffPt;

    if ((sysData->duty == PWM_WITH_DTFACT(PWR_LF_CAL_INITPWM)) && (pwrLFcalData->cnt > PWR_LF_CAL_INITDIMTIME) && (pwrLFcalData->set == PWR_LF_CAL_ON))
    {
        /* Save the current at PWR_LF_CAL_INITPWM */
        pwrLFcalData->valMin = pwrData->kw;

        /* Set the final dimming to finish the calibration */
        sysData->dtSttMch = PWM_WITH_DTFACT(PWR_LF_CAL_FINALPWM);
        sysData->flagDim = 1;

        /* Save the configs to EEPROM */
        buffPt = &pwrLFcalData->set;
        RTC_MCP7952x_WrtEEPROM_Array(PWR_LF_CAL_ADD, buffPt, PWR_LF_CAL_DATA_SIZE);

        /* Set the 2nd state for the calibration */
        pwrLFcalData->set = PWR_LF_CAL_2NDSTT;
    }
    else if ((sysData->duty == PWM_WITH_DTFACT(PWR_LF_CAL_FINALPWM)) && (pwrLFcalData->cnt > PWR_LF_CAL_TOTDIMTIME) && (pwrLFcalData->set == PWR_LF_CAL_2NDSTT))
    {
        /* Save the current at PWR_LF_CAL_FINALPWM */
        pwrLFcalData->valMax = pwrData->kw;

        /* Set the anterior dimming */
        sysData->dtSttMch = pwrLFcalData->actDim;
        sysData->flagDim = 1;

        pwrLFcalData->cnt = 0;
        pwrLFcalData->set = PWR_LF_CAL_OFF;

        /* Save the configs to EEPROM */
        buffPt = &pwrLFcalData->set;
        RTC_MCP7952x_WrtEEPROM_Array(PWR_LF_CAL_ADD, buffPt, PWR_LF_CAL_DATA_SIZE);
    }
}


#ifdef POWER_METER
/**
 * Function to calculate power consumption
 * @param 1 - SYS_STRUCT pointer
 * @param 2 - PWR_CONSUME_STRUCT pointer
 * @param 3 - PM_STRUCT pointer
 */
__attribute__((mips16)) void SYS_calcKWh(PWR_CONSUME_STRUCT *pwrData)
{
    uint8_t *buffPt;

    /* Calculate the kwh - once the calculation is made in intervals of X minutes
     * the value divides one hour 3600/X
     * -> Then convert from Wh to KWh
     */
    pwrData->kwh = (pwrData->kw / pwrData->intr2hs);
    pwrData->kvarh = (pwrData->kvar / pwrData->intr2hs);

    /* Add the power consumption calculated to the sum of KWh and VArh */
    pwrData->kwhSum += pwrData->kwh;
    pwrData->kvarhSum += pwrData->kvarh;

    /* Save the calculations and init flag */
    buffPt = &pwrData->kwhSum;
    RTC_MCP7952x_WrtEEPROM_Array(POWER_CALC_ADD, buffPt, POWER_CALC_DATA_SIZE);

    /* Clear the KW and VAr values */
    pwrData->kw = 0.0;
    pwrData->kvar = 0.0;
}
#endif


/* Power-Meter Functions */

/* Function to process the messages received of the Power-Meter */
__attribute__((mips16)) int8_t PM_MCP39F501_ProcessMsg(SYS_STRUCT *sysData, UART_STRUCT *uartData,\
                                                       PM_STRUCT *pmData, PWR_CONSUME_STRUCT *pwrData)
{
    uint8_t *buffPt;
    int8_t ans=PM_WAITING;

    if (uartData->indRx == PM_ACK_NACK_LEN)
    {
        if (uartData->rxBuff[0] == 0x06)
        {
            /* It is an acknowledge msg */
            ans = PM_MSG_OK;
        }
        else
        {
            /* It is a not acknowledge or an error msg */
            ans = PM_MSG_ERROR;
        }
    }
    else if (uartData->indRx > 1)
    {
        switch(pmData->msgID)
        {
            case PM_READVALS_ID:

                /* Procedure for the Data Read message */

                /* The memcpy have to be in 2 steps because the structure have 2 bytes more than the buffer */
                buffPt = &pmData->volt;
                memcpy(buffPt, uartData->rxBuff+PM_HEADER_ANS_LEN, PM_V_HZ_ANALOG_PF_LEN+PM_A_W_VAR_VA_LEN);


                /* Normalise measured values ans check for error on the measures */
                if (PM_MedianCalc(sysData, pwrData, pmData) == PM_ERROR)
                {
                    /* If the values have errors set the values to 0 and exit the function */
                    pmData->volt = 0;
                    pmData->curr = 0;
                    pwrData->kw = 0.0;
                    pwrData->kvar = 0.0;
                    pwrData->pwrFact = 1.0;
                    
                    return PM_MSG_ERROR;
                }
                else
                {
                    /* If the measures are ok, save the power consumption */

                    /* Copy the rest of the measurements */
                    pwrData->kw = (double)(pmData->actPwr) * PM_PWR_DIV;
                    pwrData->kvar = (double)(pmData->reactPwr) * PM_PWR_DIV;
                    //pwrData->kva = (double)(pmData->appPwr) * PM_PWR_DIV;


                    /* Alternative calculation of Apparent Power (S), using Active Power(P) and Reactive Power (Q)
                    * The value obtained from power meter isn't correct at the no-load condition */
                    pwrData->kva = sqrt((pwrData->kw * pwrData->kw) + (pwrData->kvar * pwrData->kvar));

                    /* "Manual" calculation of the Power Factor = S/P */
                    if (pwrData->kva > 0.0)
                        pwrData->pwrFact = pwrData->kw / pwrData->kva;

                    /* Correct the Current value in case of NO LOAD condition */
                    if (sysData->duty == 0)
                        sysData->current = (uint16_t)(((pwrData->kw*1000.0) / (sysData->volt * pwrData->pwrFact)) * 1000.0);
                    
                }

                /* Check if it is the first measure */
                if (pmData->initFlag == 0)
                {
                    /* Run this check only once */
                    pmData->initFlag = 1;

                    /* Check the working power supply frequency */
                    if ((pmData->freq > PWR_FREQ_50Hz_MIN) && (pmData->freq < PWR_FREQ_50Hz_MIN))
                        sysData->pwrFreq = PWR_FREQ_50Hz;
                    else if ((pmData->freq > PWR_FREQ_60Hz_MIN) && (pmData->freq < PWR_FREQ_60Hz_MAX))
                        sysData->pwrFreq = PWR_FREQ_60Hz;
                    else
                        sysData->pwrFreq = PWR_FREQ_50Hz;

                    /* Set the system update to save the frequency to EEPROM */
                    sysData->updateID = PWR_FREQ_UPDATE;
                }
                
                ans = PM_MSG_OK;
                break;

            case PM_READ_CALGAINS_ID:
                //buffPt = &pmData->debugBuff[0];
                //memcpy(buffPt, uartData->rxBuff+PM_HEADER_ANS_LEN, 2);

                ans = PM_MSG_OK;
                break;

            case PM_SAVE_REG_FLASH_ID:
                #if DEBUG_PM_RCVMSG
                    UART_PrintString("\n\nS2F Msg Ok!\n\n");
                #endif
                ans = PM_MSG_OK;
                break;
                
            default:
                #if DEBUG_PM_RCVMSG
                    sprintf(uart.txBuff, "\n\nERROR, Msg ID: %d\n\n", pmData->msgID);
                    UART_PrintString(uart.txBuff);
                #endif
                ans = PM_MSG_ERROR;
                break;
        }                
    }

    /* Reset msg ID */
    pmData->msgID = 0;
    
    /* Clear Sent flag */
    pmData->msgSent = PM_NO_MSG_SENT;

    return ans;
}


/* Function to calibrate the Power-Meter */
__attribute__((mips16)) uint8_t PM_MCP39F501_Calib( PM_STRUCT *pmData, SYS_STRUCT *sysData)
{

    if (pmData->msgAnsRcv == PM_MSG_OK)
    {
        pmData->flagCal++;

        if (pmData->flagCal > PM_SYSCONF_ADC_ON_STT)
        {
            pmData->flagCal = PM_END_CAL;

            return 0;
        }
    }

    /* Do the calibration of the */
    switch(pmData->flagCal)
    {
        case PM_SET_TGT_RNG_STT:
            pmData->msgID = PM_SET_TGT_RNG_ID;
            break;

        case PM_SET_GAINS_STT:
            pmData->msgID = PM_SET_GAINS_ID;
            break;

        case PM_SET_OFFSET_STT:
            pmData->msgID = PM_SET_OFFSET_ID;
            break;            
            
        case PM_SYSCONF_ADC_OFF_STT:
            pmData->msgID = PM_SYSCONF_ADC_OFF_ID;
            break;            
            
        case PM_SYSCONF_ADC_ON_STT:
            pmData->msgID = PM_SYSCONF_ADC_ON_ID;
            break;                        
            
        /*case PM_CALIBTEMP_STT:
            pmData->msgID = PM_CALTEMP_ID;
            break;*/

        /*case PM_SET_TGT_FREQ_STT:
            pmData->msgID = PM_SET_TGT_FREQ_ID;
            break;*/

        /*case PM_AUTO_CALFREQ_STT:
            pmData->msgID = PM_CALIB_FREQ_ID;
            break;*/

        /*case PM_AUTO_CALACT_STT:
            pmData->msgID = PM_CALIB_ACT_ID;
            break;*/

        /*case PM_AUTO_CALREACT_STT:
            pmData->msgID = PM_CALIB_REACT_ID;
            break;*/

        default:
            break;
    }

    /* Send message to Power-Meter if there is no pending answer */
    if ((pmData->msgSent == PM_NO_MSG_SENT) || ((pmData->msgSent == PM_MSG_SENT) && (pmData->msgAnsRcv == PM_MSG_OK)))
    {
        PM_MCP39F501_SendMsg(pmData, sysData);

        /* Set the flag to wait for the reply before send another message */
        pmData->msgAnsRcv = PM_WAITING;
    }

    return 0;
}


/* Read range and target
pmData->buff[0] = PM_HEADER;
pmData->buff[1] = PM_READVALS_LEN;
pmData->buff[2] = PM_SET_ADD_PT;
pmData->buff[3] = 0x00;
pmData->buff[4] = PM_RANGE;
pmData->buff[5] = PM_READ_N;
pmData->buff[6] = 18;                                         // Number of bytes to read
checksum = PM_MCP39F501_CksCalc(pmData->buff, PM_READVALS_LEN);
pmData->buff[7] = checksum; */


/* Function to send the messages for the Power-Meter */
__attribute__((mips16)) void PM_MCP39F501_SendMsg(PM_STRUCT *pmData, SYS_STRUCT *sysData)
{
    uint8_t checksum;

    /* Set the header */
    pmData->buff[0] = PM_HEADER;

    switch(pmData->msgID)
    {
        case PM_READVALS_ID:
            pmData->msgLen = PM_READVALS_LEN;
            
            pmData->buff[1] = PM_READVALS_LEN;
            pmData->buff[2] = PM_SET_ADD_PT;
            pmData->buff[3] = 0x00;
            pmData->buff[4] = PM_VOLTAGE_RMS;
            pmData->buff[5] = PM_READ_N;
            pmData->buff[6] = PM_READ_VALS_B2R;                 //Number of bytes to read

            break;

        case PM_CALTEMP_ID:
            pmData->msgLen = PM_CALTEMP_LEN;

            pmData->buff[1] = PM_CALTEMP_LEN;
            pmData->buff[2] = PM_SET_ADD_PT;
            pmData->buff[3] = 0x00;
            pmData->buff[4] = PM_AMBTEMP_REF;
            pmData->buff[5] = PM_WRITE_N;
            pmData->buff[6] = PM_W_16BIT_REG_B2W;
            pmData->buff[7] = 0x00;
            pmData->buff[8] = sysData->tempPCB;
            break;

        case PM_SET_TGT_RNG_ID:
            pmData->msgLen = PM_SET_TGT_RNG_LEN;

            pmData->buff[1] = PM_SET_TGT_RNG_LEN;
            pmData->buff[2] = PM_SET_ADD_PT;
            pmData->buff[3] = 0x00;
            pmData->buff[4] = PM_RANGE;
            pmData->buff[5] = PM_WRITE_N;
            pmData->buff[6] = 0x12;             // Number of bytes to be written
            pmData->buff[7] = 0x12;             // range 1 - voltage
            pmData->buff[8] = 0x09;             // range 2 - current
            pmData->buff[9] = 0x10;             // range 3 - active power
            pmData->buff[10] = 0x00;            // range 3
            pmData->buff[11] = 0xF4;            // current 1 - at 1 power factor
            pmData->buff[12] = 0x06;            // current 2
            pmData->buff[13] = 0x00;            // current 3
            pmData->buff[14] = 0x00;            // current 4
            pmData->buff[15] = 0x25;            // voltage 1 - at 1 power factor
            pmData->buff[16] = 0x09;            // voltage 2
            pmData->buff[17] = 0x44;            // Active Power 1 - at 1 power factor
            pmData->buff[18] = 0x10;            // Active Power 2
            pmData->buff[19] = 0x00;            // Active Power 3
            pmData->buff[20] = 0x00;            // Active Power 4
            pmData->buff[21] = 0x3C;            // Reactive Power 1 - at 0.43 power factor
            pmData->buff[22] = 0xAA;            // Reactive Power 2
            pmData->buff[23] = 0x00;            // Reactive Power 3
            pmData->buff[24] = 0x00;            // Reactive Power 4
            break;

        case PM_SET_TGT_FREQ_ID:
            pmData->msgLen = PM_SET_TGT_FREQ_LEN;

            pmData->buff[1] = PM_SET_TGT_FREQ_LEN;
            pmData->buff[2] = PM_SET_ADD_PT;
            pmData->buff[3] = 0x00;
            pmData->buff[4] = PM_LINE_FREQ_REF;
            pmData->buff[5] = PM_WRITE_N;
            pmData->buff[6] = PM_W_16BIT_REG_B2W;
            pmData->buff[7] = 0xC3;             // Line Freq Ref 1
            pmData->buff[8] = 0x50;             // Line Freq Ref 2
            break;

        case PM_CALIB_FREQ_ID:
            pmData->msgLen = PM_CALIB_FREQ_LEN;

            pmData->buff[1] = PM_CALIB_FREQ_LEN;
            pmData->buff[2] = PM_AUTO_CAL_F;
            break;

        case PM_CALIB_ACT_ID:
            pmData->msgLen = PM_CALIB_ACT_LEN;

            pmData->buff[1] = PM_CALIB_ACT_LEN;
            pmData->buff[2] = PM_AUTO_CAL_G;
            break;

        case PM_CALIB_REACT_ID:
            pmData->msgLen = PM_CALIB_REACT_LEN;

            pmData->buff[1] = PM_CALIB_REACT_LEN;
            pmData->buff[2] = PM_AUTO_CAL_RG;
            break;

        case PM_READ_CALGAINS_ID:
            //pmData->msgLen = PM_READVALS_LEN;

            /* Read calibration gains */
            /*pmData->buff[1] = PM_READVALS_LEN;
            pmData->buff[2] = PM_SET_ADD_PT;
            pmData->buff[3] = 0x00;
            pmData->buff[4] = PM_DEVICE_ADD;
            pmData->buff[5] = PM_READ_N;
            pmData->buff[6] = 10;*/

            /* Read freq calibration gain */
            pmData->msgLen = 10;
            pmData->buff[1] = 10;
            pmData->buff[2] = PM_SET_ADD_PT;
            pmData->buff[3] = 0x00;
            //pmData->buff[4] = PM_GAIN_LINE_FREQ;
            pmData->buff[4] = PM_PHASE_COMP;
            //pmData->buff[4] = PM_DC_OS_CURR;
            pmData->buff[5] = PM_READ_N;
            pmData->buff[6] = PM_R_16BIT_REG_B2R;

            break;

        case PM_SET_GAINS_ID:
            pmData->msgLen = PM_SET_GAINS_LEN;

            pmData->buff[1] = PM_SET_GAINS_LEN;
            pmData->buff[2] = PM_SET_ADD_PT;
            pmData->buff[3] = 0x00;
            pmData->buff[4] = PM_GAIN_CURR_RMS;
            pmData->buff[5] = PM_WRITE_N;
            pmData->buff[6] = PM_SET_GAINS_B2W;
#ifdef _NEMA_            
            pmData->buff[7] = 0x10;               // Gain current RMS 1
            pmData->buff[8] = 0x78;               // Gain current RMS 2
            pmData->buff[9] = 0xE8;               // Gain voltage RMS 1
            pmData->buff[10] = 0xAE;              // Gain voltage RMS 2
            pmData->buff[11] = 0x1E;              // Gain active power 1 0x93
            pmData->buff[12] = 0x76;              // Gain active power 2 0x71
            pmData->buff[13] = 0x1E;              // Gain reactive power 1
            pmData->buff[14] = 0x64;              // Gain reactive power 2
#else
            pmData->buff[7] = 0xCE;               // Gain current RMS 1
            pmData->buff[8] = 0x7A;               // Gain current RMS 2
            pmData->buff[9] = 0x4E;               // Gain voltage RMS 1
            pmData->buff[10] = 0xAE;              // Gain voltage RMS 2
            pmData->buff[11] = 0xD6;              // Gain active power 1
            pmData->buff[12] = 0x79;              // Gain active power 2
            pmData->buff[13] = 0xC1;              // Gain reactive power 1
            pmData->buff[14] = 0x6F;              // Gain reactive power 2
#endif
            break;

        case PM_SET_OFFSET_ID:
            pmData->msgLen = PM_SET_OFFSET_LEN;
            
            pmData->buff[1] = PM_SET_OFFSET_LEN;
            pmData->buff[2] = PM_SET_ADD_PT;
            pmData->buff[3] = 0x00;
            pmData->buff[4] = PM_OS_CURR_RMS;
            pmData->buff[5] = PM_WRITE_N;
            pmData->buff[6] = PM_SET_OFFSET_B2W;
#ifdef _NEMA_
            pmData->buff[7] = 0x02;               // Offset Current RMS 1 - MSB is the sign of the offset
            pmData->buff[8] = 0x00;               // Offset Current RMS 2
            pmData->buff[9] = 0x00;               // Offset Current RMS 3
            pmData->buff[10] = 0x00;              // Offset Current RMS 4
            pmData->buff[11] = 0x00;              // Offset Active Power 1
            pmData->buff[12] = 0x00;              // Offset Active Power 2
            pmData->buff[13] = 0x00;              // Offset Active Power 3
            pmData->buff[14] = 0x00;              // Offset Active Power 4
            pmData->buff[15] = 0x00;              // Offset Reactive Power 1
            pmData->buff[16] = 0x00;              // Offset Reactive Power 2
            pmData->buff[17] = 0x00;              // Offset Reactive Power 3
            pmData->buff[18] = 0x00;              // Offset Reactive Power 4
            pmData->buff[19] = 0x00;              // DC Offset Current 1
            pmData->buff[20] = 0x00;              // DC Offset Current 2
            pmData->buff[21] = 0xFF;              // Phase Compensation 1
            pmData->buff[22] = 0xD3;              // Phase Compensation 2
#else
            pmData->buff[7] = 0x03;               // Offset Current RMS 1 - MSB is the sign of the offset
            pmData->buff[8] = 0x00;               // Offset Current RMS 2
            pmData->buff[9] = 0x00;               // Offset Current RMS 3
            pmData->buff[10] = 0x00;              // Offset Current RMS 4
            pmData->buff[11] = 0x36;              // Offset Active Power 1
            pmData->buff[12] = 0x01;              // Offset Active Power 2
            pmData->buff[13] = 0x00;              // Offset Active Power 3
            pmData->buff[14] = 0x00;              // Offset Active Power 4
            pmData->buff[15] = 0x96;              // Offset Reactive Power 1
            pmData->buff[16] = 0x00;              // Offset Reactive Power 2
            pmData->buff[17] = 0x00;              // Offset Reactive Power 3
            pmData->buff[18] = 0x00;              // Offset Reactive Power 4
            pmData->buff[19] = 0x00;              // DC Offset Current 1
            pmData->buff[20] = 0x00;              // DC Offset Current 2
            pmData->buff[21] = 0xFF;              // Phase Compensation 1
            pmData->buff[22] = 0xD3;              // Phase Compensation 2
#endif
            break;

        case PM_SAVE_REG_FLASH_ID:
            pmData->msgLen = PM_SAVE_REG_FLASH_LEN;

            pmData->buff[1] = PM_SAVE_REG_FLASH_LEN;
            pmData->buff[2] = PM_SAVE_REG_FLASH;
            break;
            
        case PM_SYSCONF_ADC_OFF_ID:
            pmData->msgLen = PM_SYSTEM_CONF_LEN;
            
            pmData->buff[1] = PM_SYSTEM_CONF_LEN;
            pmData->buff[2] = PM_SET_ADD_PT;
            pmData->buff[3] = 0x00;
            pmData->buff[4] = PM_SYSTEM_CONF;
            pmData->buff[5] = PM_WRITE_N;
            pmData->buff[6] = PM_SYSTEM_CONF_B2W;
            pmData->buff[7] = PM_SYSCONF_ADC_OFF;       // TEMPCOMP disable, ADC Soft-Reset ON, ADC OFF, VREFEXT
            pmData->buff[8] = 0x00;                     // Baudrate 115200, ZCD disable, Single Wire transmission Disabled
            pmData->buff[9] = 0x42;                     // VREFCAL - Temperature coefficient - Default            
            pmData->buff[10] = 0x00;                    // PGA Setting Ch1 and Ch0 - Default

            break;
            
        case PM_SYSCONF_ADC_ON_ID:
            pmData->msgLen = PM_SYSTEM_CONF_LEN;
            
            pmData->buff[1] = PM_SYSTEM_CONF_LEN;
            pmData->buff[2] = PM_SET_ADD_PT;
            pmData->buff[3] = 0x00;
            pmData->buff[4] = PM_SYSTEM_CONF;
            pmData->buff[5] = PM_WRITE_N;
            pmData->buff[6] = PM_SYSTEM_CONF_B2W;            
            pmData->buff[7] = PM_SYSCONF_ADC_ON;        // TEMPCOMP disable, ADC Soft-Reset OFF, ADC ON, VREFEXT
            pmData->buff[8] = 0x00;                     // Baudrate 115200, ZCD disable, Single Wire transmission Disabled
            pmData->buff[9] = 0x42;                     // VREFCAL - Temperature coefficient - Default
            pmData->buff[10] = 0x00;                    // PGA Setting Ch1 and Ch0 - Default

            break;            
            
        default:
            pmData->msgID = 0;
            break;
    }

    checksum = PM_MCP39F501_CksCalc(pmData->buff, pmData->msgLen);
    pmData->buff[pmData->msgLen-1] = checksum;

    UART1_Send_Array(pmData->buff, pmData->msgLen);
    
    pmData->msgSent = PM_MSG_SENT;
}


/**
 * Function to normalise measures of the Power-meter
 * @param 1 - SYS_STRUCT pointer
 * @param 2 - PM_STRUCT pointer
 */
__attribute__((mips16)) int8_t PM_MedianCalc(SYS_STRUCT *sysData, PWR_CONSUME_STRUCT *pwrData, PM_STRUCT *pmData)
{

    /* Put the measure in the mean's buffer */
    pwrData->currMean.buff[pwrData->currMean.ind] = pmData->curr;
    pwrData->voltMean.buff[pwrData->voltMean.ind] = pmData->volt;

    if ((pmData->curr > MAXMAX_CURRENT) || (pmData->volt > MAXMAX_VOLT))
    {
        #if DEBUG_PM_FAIL    
            UART_PrintString("\n\nWRONG MEASUREMENTS, PM IS GOING TO BE INITIALIZED!\n\n");
        #endif
        
        /* Switch to Initialisation state */
        pmData->stt = PM_STT_INIT;
        pmData->initCnt = PM_TIME2START;        /* Do the start-up sequence */

        /* Exit from this function without saving the measures */
        return -1;
    }

    if (pwrData->currMean.ind < N_MEAN)
        pwrData->currMean.ind++;
    else
        pwrData->currMean.ind = 0;

    if (pwrData->voltMean.ind < N_MEAN)
        pwrData->voltMean.ind++;
    else
        pwrData->voltMean.ind = 0;

    sysData->current = (uint16_t)(mediana9(pwrData->currMean.buff) / 10);
    sysData->volt = (uint16_t)(mediana9(pwrData->voltMean.buff) / 10);

    return 0;
}


/**
 * Function to calculate the get a more accurate value of an ADC channel
 * @param 1 - buffer pointer (buffer must have 9 samples)
 */
__attribute__((mips16)) uint32_t mediana9(uint32_t *buff)
{
    uint32_t val=0, min;
    uint8_t u, k;
    uint8_t ind[5]={9,9,9,9,9};

    for(k=0; k<5; k++)
    {
        //min = ADC_MAX_VALUE;
        min = 0xFFFFFFFF;

        for (u=0; u<9; u++)
        {
            if ((buff[u] <= min) && (buff[u] >= val) && (ind[0] != u) && (ind[1] != u) \
                && (ind[2] != u) && (ind[3] != u) && (ind[4] != u))
            {
                min = buff[u];
                ind[k] = u;
            }
        }
        val = min;
    }

    return val;
}


/**
 * Function to manage the power-meter
 * @param 1 - SYS_STRUCT pointer
 * @param 2 - PM_STRUCT pointer
 * @requisites - This function only works correctly if it is called each 1s 
 */
__attribute__((mips16)) void PM_SttMachine(SYS_STRUCT *sysData, PM_STRUCT *pmData, RF_STRUCT *rfData)
{

    /* Count the time to start the PM interaction */
    if (pmData->initCnt <= PM_TIME2START)
        pmData->initCnt++;

    switch(pmData->stt)
    {
        case PM_STT_WAIT:
            
             /* If the wait state is completed switch to the initialisation of the PM */
            if (pmData->initCnt == PM_TIME2INIT)
                pmData->stt = PM_STT_INIT;
            
            break;
            
        case PM_STT_INIT:            
            
            /* Reset the AFE */
            PM_MCP39F501_Init();
            
            /* Initialise calibration flags */
            pmData->flagCal = 0;
            pmData->calTimeOut = 0;
            pmData->initFlag = 0;
            
            /* Set an error in the answer flag to (re)start the calibration */
            pm.msgAnsRcv = PM_MSG_ERROR;
            
            /* Completed the Init sequence switch state */
            pmData->stt = PM_STT_CAL;
            
            break;
            
        case PM_STT_CAL:
            
            /* Check if time to start the calibration */
            if (pmData->initCnt > PM_TIME2START)
            {
                // Check if is the first cycle of the infinite cycle
                if ((pmData->flagCal < PM_END_CAL) && (pmData->calTimeOut <= PM_TIMEOUT_CAL))
                {
                    pmData->calTimeOut++;
                    
                    /* Set the gains for the power-meter */
                    PM_MCP39F501_Calib(pmData, sysData);
                }
                else if ((pmData->flagCal < PM_END_CAL) && (pmData->calTimeOut > PM_TIMEOUT_CAL))
                {
                    /* Regarding a timeout repeat the initialisation */
                    pmData->stt = PM_STT_INIT;
                    pmData->initCnt = PM_TIME2START;        /* Do the start-up sequence */
                }

                /* After a successful calibration start reading the values */
                if (pmData->flagCal == PM_END_CAL)
                    pmData->stt = PM_STT_READVALS;

            } // END if (pm.initCnt > PM_TIME2START)            
            
            break;                      
            
        case PM_STT_READVALS:          
            
            /* Check for Save Registers to Flash order */
            if (pmData->flagSave2Flash == PM_SAVE2FLASH_READY)
            {                
                /* Set the ID to send the Save Registers to Flash message */
                pmData->msgID = PM_SAVE_REG_FLASH_ID;  
                PM_MCP39F501_SendMsg(pmData, sysData);
                
                /* Clear the order and send RF msg of ACK */
                pmData->flagSave2Flash = PM_SAVE2FLASH_DONE;                 
            }
            else            
            {
                pmData->msgID = PM_READVALS_ID;
                //pmData->msgID = PM_READ_CALGAINS_ID;
                PM_MCP39F501_SendMsg(pmData, sysData);                
            }                       
            
            break;
            
        default:
            break;
    }    
    
}



/* Check if the lights should be OFF or ON, according with the astronomical clock configurations */
__attribute__((mips16)) uint8_t SYS_AstroClkCheck(ASTRO_STRUCT *astroData, RTC_DATA *rtcData)
{
    if ((astroData->minAbsSset > MINUTES_24H) || (astroData->minAbsSrise > MINUTES_24H))
    {
        astroData->dimStt = SYS_ON;
        return 1;
    }

    /* Check if the profile goes from one day to the other - ex: 22h to 4h */
    if (astroData->minAbsSset < astroData->minAbsSrise)
    {
        if ((rtcData->minAbs >= astroData->minAbsSset) && (rtcData->minAbs < astroData->minAbsSrise))
            astroData->dimStt = SYS_ON;
        else
            astroData->dimStt = SYS_OFF;
    }
    else if (astroData->minAbsSset > astroData->minAbsSrise)
    {
        if ((rtcData->minAbs >= astroData->minAbsSset) || (rtcData->minAbs < astroData->minAbsSrise))
            astroData->dimStt = SYS_ON;
        else
            astroData->dimStt = SYS_OFF;
    }

    return 0;
}


/* Astronomical Clock - Check if the dimming state has changed */
__attribute__((mips16)) void SYS_AstroClk_DimChg(ASTRO_STRUCT *astroData, SYS_STRUCT *sysData, uint8_t stt)
{
    uint8_t *buffPt;

    if (stt == SYS_OFF)
    {
        if (astroData->dimSttAnt == SYS_ON)
        {
            astroData->dimSttAnt = SYS_OFF;

            if (sysData->duty == PWM_MIN)
                astroData->dimCurr = PWM_ASTROCLK_DEFAULT;
            else
                astroData->dimCurr = sysData->dutyTmp;
        }

        if (sysData->dtSttMch != 0)
        {
            sysData->dtSttMch = 0;
            sysData->flagDim = 1;
        }
    }
    else if (stt == SYS_ON)
    {
        if (astroData->dimSttAnt == SYS_OFF)
        {
            astroData->dimSttAnt = SYS_ON;

            /* Get the dimming before the sunrise, only when there just the Astro Clk configured
               For the conjunction with profiles the dimming is going to be set after */
            if (sysData->profileStt == DIM_ASTROCLK_ON)
            {
                sysData->dtSttMch = astroData->dimCurr;

                /* Set the order to do dimming*/
                sysData->flagDim = 1;
            }
        }
    }

    /* If there was a change save the new configs */
    if (sysData->flagDim == 1)
    {
        /* Update the astronomical clock configurations to eeprom */
        buffPt = &astroData->hhSset;
        RTC_MCP7952x_WrtEEPROM_Array(ASTRO_CLK_ADD, buffPt, ASTRO_CLK_DATA_SIZE);
    }

}


/* LDR Control*/
__attribute__((mips16)) void SYS_ldrSPctrl(SYS_STRUCT *sysData)
{
    int16_t error, ldrDim;

    error = (sysData->setLDR - sysData->ldr);
    sysData->ldrS.difK = (uint16_t)(error * LDR_KP);
    sysData->ldrS.difI = (uint16_t)((sysData->ldrS.difI + error) * LDR_KI);       /* The time is 1 minute */

    sysData->ldrS.dif = sysData->ldrS.difK + sysData->ldrS.difI;

    if ((sysData->ldrS.dif != 0) && (abs(sysData->ldrS.dif) > LDR_MIN_INT))
    {
        ldrDim = sysData->dtSttMch + sysData->ldrS.dif;

        if (ldrDim > PWM_WITH_DTFACT(PWM_MAX))
            ldrDim = PWM_WITH_DTFACT(PWM_MAX);

        if (ldrDim < PWM_MIN)
            ldrDim = PWM_MIN;

        sysData->dtSttMch = ldrDim;
        sysData->flagDim = 1;
    }

#if DEBUG_LDR
    sprintf(uart.txBuff, "\n\n=10,LDRsp=%d,LDR=%d,Erro=%d,Prop=%d,Integ=%d,LDRctrlDim=%d\n\n", sysData->setLDR, sysData->ldr, error, sysData->ldrS.difK, sysData->ldrS.difI, sysData->ldrS.dif);
    UART_PrintString(uart.txBuff);
#endif

}


/* Control the system within 1min interval - LDR update */
__attribute__((mips16)) void SYS_1minCtrl(SYS_STRUCT *sysData, RTC_DATA *rtcData, PROF_STRUCT *profData, RF_STRUCT *rfData, PWR_LF_CAL_STRUCT *pwrLFcalData)
{
    /* Control the first time in this function and the Save Register to Flash in the PM */
    if (sys.flagInit == 1)
    {
        sys.flagInit = 0;
        pm.flagSave2Flash = PM_SAVE2FLASH_WAIT;                             
    }
    else if (pm.flagSave2Flash == PM_SAVE2FLASH_WAIT)
    {
        pm.flagSave2Flash = PM_SAVE2FLASH_READY;              
    }      
    
    /* Check if there is a valid Lux measure */
    if ((sysData->ldrS.ready == 1) && (pwrLFcalData->set == PWR_LF_CAL_OFF))
    {
        sysData->ldrS.ready = 0;

        /* Check if LDR control is ON or profiles ON and outside the profiles
         * In this way the local LDR control works as the external control      */
        if ( (sysData->ldrCtrl > LDR_OFF) && \
             ((sysData->profileStt == SYS_OFF) || ((sysData->profileStt == SYS_ON) && (profData->profFlag == NO_PROFILES))) )
        {
            /* Profiles OFF or no profile defined and LDR control ON */
            if (sysData->ldrS.inFlag == ENABLE)
            {
                if (sysData->ldrCtrl == LDR_THR)
                {
                    /* LDR control in Threshold mode */                
                    if (sysData->ldr > sysData->setLDR + LDR_HYST)
                    {
                        sysData->dtSttMch = PWM_MIN;
                        sysData->flagDim = 1;
                    }
                    else if (sysData->ldr < sysData->setLDR - LDR_HYST)
                    {
                        /* Set the duty to PWM_MAX and do the dimming */
                        sysData->dtSttMch = PWM_WITH_DTFACT(PWM_LDR_DEFAULT);
                        sysData->flagDim = 1;
                    }
                }
                else if (sysData->ldrCtrl == LDR_SP)
                {
                    /* LDR control in Setpoint mode */
                    SYS_ldrSPctrl(sysData);                    
                }
            }
            else 
            {
                sysData->dtSttMch = PWM_WITH_DTFACT(PERCENT_TO_DUTY(sysData->ldrS.ldrDuty));            
                sysData->flagDim = 1;
            }

            /* Set the order to share the LDR info - if it is enabled */
#ifndef _NEMA_
            if (sysData->ldrS.inFlag == ENABLE) rfData->msgIDsend = LDR_CONTROL_SEND;
#endif

        } // END if (sysData->ldrCtrl > LDR_OFF) ...

    } // END if (sysData->ldrReady == 1)

}



/* Update system within 1s interval, if configured send debug information by serial port */
__attribute__((mips16)) void SYS_1sUpdate(RF_STRUCT *rfData, SYS_STRUCT *sysData, RTC_DATA *rtcData, PROF_STRUCT *profData, ASTRO_STRUCT *astroData,\
                                          PWR_LF_CAL_STRUCT *pwrLFcalData, ALARM_STRUCT *alrData, PWR_CONSUME_STRUCT *pwrData, PM_STRUCT *pmData)
{
    /* Increment counter for the time between consecutive messages */
    if (rfData->cnt5s > 0)
    {
        rfData->cnt5s++;

        if (rfData->cnt5s > 5)
        {
            rfData->cnt5s = 0;

            /* Clear msg buffer */
            memset(msgBuffPt, 0x00, DATA_SIZE_CLEAR);
        }
    }

    /* Update clock */
    RTC_MCP7952x_ReadCalendar(rtcData);

    /* Using the minutes of the RTC instead of the flag1min, all the controllers check the profile at the same time */
    if (rtcData->minutes != rtcData->minOld)
    {
        /* Update clock information */
        rtcData->minAbs = rtcData->hours*60 + rtcData->minutes;
        rtcData->minOld = rtcData->minutes;
        sysData->flagChkProf = 1;
    }

    /* Check if time to turn OFF or ON the dimming */
    if ((sysData->profileStt == DIM_ASTROCLK_ON) || (sysData->profileStt == DIM_PROF_ASTO_ON))
        SYS_AstroClkCheck(astroData, rtcData);
    else
        astroData->dimStt = SYS_ON;

    /*************************************************************/
    /* Debug                                                         /
    /*************************************************************/
                    
#if DEBUG_1SFLAG
    if (sysData->debugCtrl == SYS_ON && jigFlag == JIG_OFF)
    {
        dtFactInt = (uint8_t)(sysData->dutyFact*100);
              
        sprintf(uart.txBuff, "=1,SN=%d,NET=%d,H=%d:%d:%d,D=%d/%d/%d,MAbs=%d,ENC=%d,RFFreq=%d,WH=%lu\n", sysData->sn, sysData->net, rtcData->hours, \
                rtcData->minutes, rtcData->seconds, rtcData->date, rtcData->month, rtcData->year, rtcData->minAbs, sysData->encCtrl, rfData->freq, sysData->workHours);
        UART_PrintString(uart.txBuff);

        sprintf(uart.txBuff, "=2,Sys=%d,Prof=%d/%d,LDRc=%d,TTL=%d,DUTY=%d,dutyFact=%d,PIRc=%d,PIRenable=%d,PIRcnt=%d,PwrF=%d,SysF=%d\n", sysData->sysStt, sysData->profileStt, \
                profData->profFlag, sysData->ldrCtrl, sysData->ttlMAX, sysData->duty, dtFactInt, sysData->pirCtrl, sysData->pirENABLE, sysData->pirCnt, pmData->freq, sysData->pwrFreq);
        UART_PrintString(uart.txBuff);
        
        sprintf(uart.txBuff, "=3,DIGIN_1=%d | DIGIN_2=%d | DIGIN_3=%d | DIGIN_4=%d\n", DIGIN_1, DIGIN_2, DIGIN_3, DIGIN_4);
        UART_PrintString(uart.txBuff);
        
        //sprintf(uart.txBuff, "=4,ANA_1=%d | ANA_2=%d | ANA_3=%d | ANA_4=%d | I1 = %6.4f \r\n\n", analog_1, analog_2, analog_3, analog_4, i1);
        sprintf(uart.txBuff, "=4,ANA_1=%d | ANA_2=%d | ANA_3=%d | ANA_4=%d | I1(Q) = %6.4f | I2(vol) = %6.4f \r\n", analog_1, analog_2, analog_3, analog_4, flowAct, i2);
        UART_PrintString(uart.txBuff);
        
        sprintf(uart.txBuff,"=5,AN1 ax2 + bx + c -> a=%10.4f b=%10.4f c=%10.4f\r\n\n", quadratic_AN1, slope_AN1, intercept_AN1);
        UART_PrintString(uart.txBuff);
        

#if DEBUG_ASTROCLK
        sprintf(uart.txBuff, "=7,SSet=%d:%d,SRise=%d:%d,MASet=%d,MARise=%d,DimC=%d,DimSttA=%d,DimStt=%d\n\n", astroData->hhSset, \
                astroData->mmSset, astroData->hhSrise, astroData->mmSrise, astroData->minAbsSset, astroData->minAbsSrise, astroData->dimCurr, astroData->dimSttAnt, astroData->dimStt);
        UART_PrintString(uart.txBuff);
#endif

        /* Clear buffer to avoid */
        UART_ClearBuff(uart.txBuff, &uart.indTx);
    }
    
    if (jigFlag == JIG_ON)
    {
        //=SN,NET,HH,MM,SS,ENC,RFFREQ,WH,SYS,DUTY,TPCB,AMEMSX,AMEMSY,AMEMSZ,%        
        sprintf(uart.txBuff, "=%d,%d,%d,%d,%d,%d,%d,%lu,%d,%d,%d,%d,%d,%d,%d,%c\r\n",sysData->sn, sysData->net, rtcData->hours, \
               rtcData->minutes, rtcData->seconds, sysData->encCtrl, rfData->freq, sysData->workHours, sysData->sysStt,   \
               sysData->duty, sysData->tempPCB, sysData->ldr, '%');
        UART_PrintString(uart.txBuff); 
        
        UART_ClearBuff(uart.txBuff, &uart.indTx); 
        
        //UART_PrintString("\nteste\n");              
    }
    
#endif  // DEBUG_1SFLAG
    /*************************************************************/

}


/**
 * Function to implement 1h system updates
 * @param 1 - SYS_STRUCT pointer 
 * @param 2 - RF_STRUCT pointer
 */
__attribute__((mips16)) void SYS_1hUpdate(SYS_STRUCT *sysData, RF_STRUCT *rfData)
{
    uint8_t *whPt;

    /* Update Workhours and save to EEPROM */
    sysData->workHours++;

    whPt = &sysData->workHours;
    RTC_MCP7952x_WrtEEPROM_Array(WH_ADD, whPt, UINT32_SIZE);
    
#ifdef RF_RFM22B   
    /* Check for RF Crash situation - No communication within 24h */
    sysData->flag24h++;
    
    if (sysData->flag24h > 23)
    {
        sysData->flag24h = 0;
        
        /* If no messages were received within a 24h interval reset the RF module */
        if (rfData->msgRcv == 0)
            RF_RFM22B_Reset(rfData);
        else
            rfData->msgRcv = 0;
    }
#endif
#ifdef RF_RFM69HCW
    /* Avoid RF Crash situation */
    sysData->flag12h++;
    
    if (sysData->flag12h > 11)
    {
        sysData->flag12h = 0;
        RF_RFM69HCW_Reset(rfData);
    }
#endif
#ifdef RF_RFM95W
    /* Avoid RF Crash situation */
    sysData->flag24h++;
    
    if (((RF_RFM95W_ReadReg(RF_REG_OPMODE) & 0x07) == 0x00) || (sysData->flag24h > 23 && rfData->msgRcv == 0)) //Verifies if radio has reseted 
    {
        RF_RFM95W_Reset(rfData); //Re-configures radio        
    }
    
    if (sysData->flag24h > 23)
    {
        sysData->flag24h = 0;
        rfData->msgRcv = 0; 
    }
#endif    
}
    

/* Encryption functions */

/* The session_key should have been calculated before
 * Returns the new length of the message
 */
__attribute__((mips16)) uint8_t AES128_Encrypt(uint8_t *buff, uint8_t buffLen, uint8_t *buffEnc, void *sessionKey)
{    
    /* Copy to auxiliary buffer and add the length of the original message */
    auxLen = buffLen + 1;
    auxBuff[0] = buffLen;
    memcpy(auxBuff+1, buff, auxLen);    
    
    /* The encryption is done in a 16bit block size*/
    if ((auxLen <= AES_BLOCK_SIZE) && (auxLen > 0))
    {
        /* block until 16 bytes */

        /* Set the rest of the bytes to 0 */
        if (auxLen < AES_BLOCK_SIZE) memset(auxBuff+auxLen, 0, AES_BLOCK_SIZE-auxLen);

        AESECBEncryptBlock(auxBuff, sessionKey, buffEnc, AES_KEY_TYPE_128_BIT);

        return AES_BLOCK_SIZE;
    }
    else if ((auxLen > AES_BLOCK_SIZE) && (auxLen <= AES_BLOCK_SIZE_2))
    {
        /* block with more than 16 bytes to 32 bytes */

        /* Encrypt the first block already in auxBuff */
        AESECBEncryptBlock(auxBuff, sessionKey, buffEnc, AES_KEY_TYPE_128_BIT);
        
        /* Set the rest of the bytes to 0 */
        if (auxLen < AES_BLOCK_SIZE_2) memset(auxBuff+auxLen, 0, AES_BLOCK_SIZE_2-auxLen);          

        /* Encrypt the second block */
        AESECBEncryptBlock(auxBuff+AES_BLOCK_SIZE, sessionKey, buffEnc+AES_BLOCK_SIZE, AES_KEY_TYPE_128_BIT);

        return AES_BLOCK_SIZE_2;
    }
    else if ((auxLen > AES_BLOCK_SIZE_2) && (auxLen <= AES_BLOCK_SIZE_3))
    {
        /* block with more than 32 bytes */

        /* Encrypt the first block already in auxBuff */
        AESECBEncryptBlock(auxBuff, sessionKey, buffEnc, AES_KEY_TYPE_128_BIT);
        
        /* Encrypt the second block */
        AESECBEncryptBlock(auxBuff+AES_BLOCK_SIZE, sessionKey, buffEnc+AES_BLOCK_SIZE, AES_KEY_TYPE_128_BIT);
        
        /* Set the rest of the bytes to 0 */
        if (auxLen < AES_BLOCK_SIZE_3) memset(auxBuff+auxLen, 0, AES_BLOCK_SIZE_3-auxLen);          

        /* Encrypt the third block */
        AESECBEncryptBlock(auxBuff+AES_BLOCK_SIZE_2, sessionKey, buffEnc+AES_BLOCK_SIZE_2, AES_KEY_TYPE_128_BIT);

        return AES_BLOCK_SIZE_3;
    }
    
    /* Return 0 if the message isn't valid */
    return 0;
}



/* The session_key should have been calculated before */
__attribute__((mips16)) uint8_t AES128_Decrypt(uint8_t *buffEnc, uint8_t buffLen, uint8_t *buffDec, void *sessionKey)
{    
    /* The encryption is done in a 16bit block size*/
    if (buffLen == AES_BLOCK_SIZE)
    {
        /* block of 16 bytes */
        AESECBDecryptBlock(buffEnc, sessionKey, auxBuff, AES_KEY_TYPE_128_BIT);
    }
    else if (buffLen == AES_BLOCK_SIZE_2)
    {
        /* block with 32 bytes */

        /* Decrypt the first block */
        AESECBDecryptBlock(buffEnc, sessionKey, auxBuff, AES_KEY_TYPE_128_BIT);

        /* Decrypt the second block */
        AESECBDecryptBlock(buffEnc+AES_BLOCK_SIZE, sessionKey, auxBuff+AES_BLOCK_SIZE, AES_KEY_TYPE_128_BIT);
    }
    else if (buffLen == AES_BLOCK_SIZE_3)
    {
        /* block with 48 bytes */

        /* Decrypt the first block */
        AESECBDecryptBlock(buffEnc, sessionKey, auxBuff, AES_KEY_TYPE_128_BIT);

        /* Decrypt the second block */
        AESECBDecryptBlock(buffEnc+AES_BLOCK_SIZE, sessionKey, auxBuff+AES_BLOCK_SIZE, AES_KEY_TYPE_128_BIT);
        
        /* Decrypt the third block */
        AESECBDecryptBlock(buffEnc+AES_BLOCK_SIZE_2, sessionKey, auxBuff+AES_BLOCK_SIZE_2, AES_KEY_TYPE_128_BIT);
    }
    else
    {
        /* Not a valid message */
        return 0;
    }

    /* Copy from auxiliary buffer */
    memcpy(buffDec, auxBuff+1, buffLen);       
    
    /* Return the length of the message decrypted */
    return auxBuff[0];
}

__attribute__((mips16)) void SYS_ClearBuff(uint8_t *buff, uint8_t len)
{
    memset(buff, 0, len);
}

__attribute__((mips16)) void SYS_calcVolume(PWR_CONSUME_STRUCT *pwrData)
{
    uint8_t *buffPt;
        
    volume = volume + flowAvg * (1.0 / pwrData->intr2hs); //volume = volume + flow * 30s/3600s
    //volume = volume + i1*(1.0/pwrData->intr2hs); //volume = volume + flow * 30s/3600s
    
    if (volume > 2000000000.0) volume = 0.0;
    
    i1 = flowAvg; // insert flow average in powermeter data protocol
    i2 = volume; // insert volume in powermeter data protocol
    
    /* Reseting average variables */
    flowSum = 0.0;
    avgCnt = 0;
    
    /* Save the calculations and init flag */
    pwrData->kwhSum = (double)volume;    
    
    buffPt = &pwrData->kwhSum;
    RTC_MCP7952x_WrtEEPROM_Array(POWER_CALC_ADD, buffPt, POWER_CALC_DATA_SIZE);
}

__attribute__((mips16)) void CalcFlowAvg(void)
{    
    if (flowSum < 2000000000.0) flowSum = flowSum + flowAct;
    
    if (avgCnt < 65000) avgCnt++; 
    else 
    {
        flowSum = 0.0;
        avgCnt = 0;
    }
    
    if (avgCnt > 0) flowAvg = flowSum / ((float)avgCnt);
    else flowAvg = flowAct;
    
    //Attention: Reset flowSum and avgCnt on volume calculation method
}

__attribute__((mips16)) void ConvertLittleToBigEndian(uint8_t *b, uint8_t index)
{
    uint8_t temp;
    
    temp = b[index];
    b[index] = b[index + 1];
    b [index + 1] = temp;
}

__attribute__((mips16)) uint16_t CRC16(uint8_t *nData, uint16_t wLength)
{
    static const uint16_t wCRCTable[] = {
    0X0000, 0XC0C1, 0XC181, 0X0140, 0XC301, 0X03C0, 0X0280, 0XC241,
    0XC601, 0X06C0, 0X0780, 0XC741, 0X0500, 0XC5C1, 0XC481, 0X0440,
    0XCC01, 0X0CC0, 0X0D80, 0XCD41, 0X0F00, 0XCFC1, 0XCE81, 0X0E40,
    0X0A00, 0XCAC1, 0XCB81, 0X0B40, 0XC901, 0X09C0, 0X0880, 0XC841,
    0XD801, 0X18C0, 0X1980, 0XD941, 0X1B00, 0XDBC1, 0XDA81, 0X1A40,
    0X1E00, 0XDEC1, 0XDF81, 0X1F40, 0XDD01, 0X1DC0, 0X1C80, 0XDC41,
    0X1400, 0XD4C1, 0XD581, 0X1540, 0XD701, 0X17C0, 0X1680, 0XD641,
    0XD201, 0X12C0, 0X1380, 0XD341, 0X1100, 0XD1C1, 0XD081, 0X1040,
    0XF001, 0X30C0, 0X3180, 0XF141, 0X3300, 0XF3C1, 0XF281, 0X3240,
    0X3600, 0XF6C1, 0XF781, 0X3740, 0XF501, 0X35C0, 0X3480, 0XF441,
    0X3C00, 0XFCC1, 0XFD81, 0X3D40, 0XFF01, 0X3FC0, 0X3E80, 0XFE41,
    0XFA01, 0X3AC0, 0X3B80, 0XFB41, 0X3900, 0XF9C1, 0XF881, 0X3840,
    0X2800, 0XE8C1, 0XE981, 0X2940, 0XEB01, 0X2BC0, 0X2A80, 0XEA41,
    0XEE01, 0X2EC0, 0X2F80, 0XEF41, 0X2D00, 0XEDC1, 0XEC81, 0X2C40,
    0XE401, 0X24C0, 0X2580, 0XE541, 0X2700, 0XE7C1, 0XE681, 0X2640,
    0X2200, 0XE2C1, 0XE381, 0X2340, 0XE101, 0X21C0, 0X2080, 0XE041,
    0XA001, 0X60C0, 0X6180, 0XA141, 0X6300, 0XA3C1, 0XA281, 0X6240,
    0X6600, 0XA6C1, 0XA781, 0X6740, 0XA501, 0X65C0, 0X6480, 0XA441,
    0X6C00, 0XACC1, 0XAD81, 0X6D40, 0XAF01, 0X6FC0, 0X6E80, 0XAE41,
    0XAA01, 0X6AC0, 0X6B80, 0XAB41, 0X6900, 0XA9C1, 0XA881, 0X6840,
    0X7800, 0XB8C1, 0XB981, 0X7940, 0XBB01, 0X7BC0, 0X7A80, 0XBA41,
    0XBE01, 0X7EC0, 0X7F80, 0XBF41, 0X7D00, 0XBDC1, 0XBC81, 0X7C40,
    0XB401, 0X74C0, 0X7580, 0XB541, 0X7700, 0XB7C1, 0XB681, 0X7640,
    0X7200, 0XB2C1, 0XB381, 0X7340, 0XB101, 0X71C0, 0X7080, 0XB041,
    0X5000, 0X90C1, 0X9181, 0X5140, 0X9301, 0X53C0, 0X5280, 0X9241,
    0X9601, 0X56C0, 0X5780, 0X9741, 0X5500, 0X95C1, 0X9481, 0X5440,
    0X9C01, 0X5CC0, 0X5D80, 0X9D41, 0X5F00, 0X9FC1, 0X9E81, 0X5E40,
    0X5A00, 0X9AC1, 0X9B81, 0X5B40, 0X9901, 0X59C0, 0X5880, 0X9841,
    0X8801, 0X48C0, 0X4980, 0X8941, 0X4B00, 0X8BC1, 0X8A81, 0X4A40,
    0X4E00, 0X8EC1, 0X8F81, 0X4F40, 0X8D01, 0X4DC0, 0X4C80, 0X8C41,
    0X4400, 0X84C1, 0X8581, 0X4540, 0X8701, 0X47C0, 0X4680, 0X8641,
    0X8201, 0X42C0, 0X4380, 0X8341, 0X4100, 0X81C1, 0X8081, 0X4040 };

    uint8_t nTemp;
    uint16_t wCRCWord = 0xFFFF;

    while (wLength--)
    {
        nTemp = *nData++ ^ wCRCWord;
        wCRCWord >>= 8;
        wCRCWord ^= wCRCTable[nTemp];
    }
    return wCRCWord;
}

